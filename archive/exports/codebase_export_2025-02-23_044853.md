# Menu Updater Codebase Export

Generated on: 2025-02-23 04:48:53

# Project Overview

# Menu Updater & AI Assistant

An AI-powered tool for Swoop customers to manage their restaurant menus and query order data through natural language interactions. The application is built with a Streamlit frontend that connects to a PostgreSQL database and communicates with OpenAI's API using function-calling for structured operations.

---

## System Overview

### Core Components

1. **Frontend (Streamlit)**
   - **Chat Interface:**  
     Users interact with the AI assistant via a chat interface. The assistant can:
     - Update menu item details (e.g., price updates or toggling status).
     - Query menu information.
     - Fetch order data (e.g., total sales, revenue comparisons, frequent order metrics, etc.).
   - **Sidebar Navigation:**  
     - Location selection: Users choose the active location (e.g., restaurant branch) from a dropdown.
     - Database Schema Explorer: Visualizes the schema of the database.
     - Theme support: Dark/light mode with custom CSS for tooltips and other UI components.

2. **Database (PostgreSQL)**
   - **Schema Structure:**
     - **Locations, Menus, Categories, Items, Options, Option Items, Orders, Order Items, Ratings & Feedback.**
     - Columns include totals, timestamps, soft deletion flags, and ordering (via `seq_num`).
   - **Operations:**  
     Structured SQL queries are used for menu updates and order queries. Examples include:
     - Calculating total sales revenue for a month.
     - Comparing current month sales to the same month last year.
     - Determining top-selling menu items over a quarter.
     - Measuring average order values and time between orders.
     
3. **AI Integration (OpenAI API)**
   - **Function Calling:**  
     A set of functions is defined in **function_calling_spec.py** for the OpenAI client. Among these:
     - `categorize_request`: Determines what kind of request the user is making.
     - `update_menu_item` and `toggle_menu_item`: Execute menu update operations.
     - `query_orders`: Executes order queries against the database.
   - **Chat Processing Flow:**  
     The app compiles recent conversation history (within token limits), sends it to the OpenAI API, and checks for function calls. For a `query_orders` request, the app:
     - Retrieves the user's selected location from the sidebar.
     - Builds a SQL query (using natural language parameters like time period).
     - Executes the query using shared helper functions (mirroring tests in **tests/test_orders_query.py**).
     - Returns and displays the query results in the conversation.

---

## Application Flow

1. **Session Initialization (in app.py):**
   - **Session State Setup:**  
     Initializes the conversation history with system and assistant welcome messages.
   - **Location Selection:**  
     A sidebar dropdown loads available locations from the `locations` table. The default location (e.g., ID 62) is selected based on your configuration.
     
2. **User Interaction via Chat:**
   - A user types a query (e.g., "What was our total sales revenue for the past month?") in the chat interface.
   - The user's message is stored in the session state. All messages (user and assistant) are displayed in a Streamlit chat layout.

3. **Processing with the AI Assistant:**
   - The recent messages (filtered by token limits) are sent to the OpenAI API via the `run_chat_sequence()` function in **chat_functions.py**.
   - The OpenAI API, using the function calling specification declared in **function_calling_spec.py**, categorizes the request.
   - For order-related queries (`request_type == "query_orders"`), the assistant builds a corresponding SQL query:
     - Example: It constructs a query to calculate total revenue and order count using a date filter (e.g., today, this month, last month) and the selected `location_id`.
   - The SQL query is executed using a helper function (e.g., `execute_order_query()`), and the JSON results are returned to the chat.

4. **Displaying the Result:**
   - The assistant's response (including query results, status updates, etc.) is appended to the session state and displayed in the chat.
   - Token usage is tracked and displayed so that older messages are trimmed when necessary.

5. **Additional Operations:**
   - Menu update operations (e.g., updating prices, toggling an item's status) follow a similar flow and are executed via corresponding functions (`update_menu_item` or `toggle_menu_item`).
   - Other custom queries (mirroring those in **tests/test_orders_query.py**) can be integrated similarly by extending the function calling logic.

---

## Development Setup

1. **Clone the Repository:**
   ```bash
   git clone https://github.com/grow-assistant/menu-updater.git
   cd menu-updater
   ```

2. **Set Up Python Environment:**
   - Use Python 3.8 or higher.
   - Create and activate a virtual environment (recommended).

3. **Set Up PostgreSQL:**
   - Install PostgreSQL.
   - Create a new database for the project.
   - Run any supplied SQL scripts to create the necessary tables.

4. **Configure Environment Variables:**
   Create a `.env` file with:
   ```ini
   DB_NAME=your_db_name
   DB_USER=your_db_user
   DB_PASSWORD=your_db_password
   DB_SERVER=localhost
   OPENAI_API_KEY=your_openai_key
   ```

5. **Install Dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

6. **Run the App:**
   ```bash
   streamlit run app.py
   ```
   The app will open in your browser (typically at http://localhost:8501).

---

## Testing Order Queries

A dedicated test file (**tests/test_orders_query.py**) contains SQL queries that are used to validate various order-related operations. These queries include:
- Total sales revenue for the past month.
- Sales comparison (this month vs. same month last year).
- Top menu items by revenue.
- Average order value over time.
- Average time between a customer's first two orders.
- Customer repeat order metrics and lifetime value.

These queries leverage the same database helper functions and SQL logic that are used when handling natural language queries in the chat interface.

---

## Conclusion

By following this flow:
- **User's queries** are processed through a natural language chat interface.
- **OpenAI function calling** allows for dynamic determination of request type.
- **Database helper functions** ensure consistency between test queries and production code.
- **Streamlit's UI** provides a sleek interface for both entering queries and visualizing results.

This integration ensures that all queries—from menu updates to comprehensive order analytics—are executed accurately, providing a seamless user experience with the full flow of the application.

---

Happy Managing!



# Source Code

## Analytics

```python
"""Analytics functions for menu suggestions"""
from typing import List, Dict, Any
from datetime import datetime, timedelta

def get_item_suggestions(connection, item_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on order history"""
    try:
        with connection.cursor() as cursor:
            # Find items frequently ordered together
            cursor.execute("""
                WITH item_orders AS (
                    SELECT DISTINCT order_id 
                    FROM order_items 
                    WHERE item_id = %s
                ),
                related_items AS (
                    SELECT 
                        i.id,
                        i.name,
                        i.price,
                        c.name as category,
                        COUNT(*) as co_occurrence,
                        ROUND(COUNT(*) * 100.0 / (
                            SELECT COUNT(DISTINCT order_id) 
                            FROM order_items 
                            WHERE item_id = %s
                        ), 2) as order_percentage
                    FROM order_items oi
                    JOIN item_orders io ON oi.order_id = io.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE oi.item_id != %s
                      AND i.disabled = false
                      AND c.disabled = false
                    GROUP BY i.id, i.name, i.price, c.name
                    HAVING COUNT(*) >= 5
                    ORDER BY co_occurrence DESC, order_percentage DESC
                    LIMIT 5
                )
                SELECT 
                    id,
                    name,
                    price,
                    category,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders
                FROM related_items;
            """, (item_id, item_id, item_id))
            
            columns = ['id', 'name', 'price', 'category', 'times_ordered_together', 'percentage_of_orders']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def get_category_suggestions(connection, category_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on category relationships"""
    try:
        with connection.cursor() as cursor:
            # Find categories frequently ordered together
            cursor.execute("""
                WITH category_orders AS (
                    SELECT DISTINCT o.id as order_id
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    WHERE i.category_id = %s
                ),
                related_categories AS (
                    SELECT 
                        c.id,
                        c.name,
                        COUNT(DISTINCT co.order_id) as co_occurrence,
                        ROUND(COUNT(DISTINCT co.order_id) * 100.0 / (
                            SELECT COUNT(*) FROM category_orders
                        ), 2) as order_percentage,
                        ARRAY_AGG(DISTINCT i.name) as popular_items
                    FROM category_orders co
                    JOIN order_items oi ON co.order_id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE c.id != %s
                      AND c.disabled = false
                    GROUP BY c.id, c.name
                    HAVING COUNT(DISTINCT co.order_id) >= 3
                    ORDER BY co_occurrence DESC
                    LIMIT 3
                )
                SELECT 
                    id,
                    name,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders,
                    popular_items
                FROM related_categories;
            """, (category_id, category_id))
            
            columns = ['id', 'name', 'times_ordered_together', 'percentage_of_orders', 'popular_items']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def format_suggestion_message(item_suggestions: List[Dict[str, Any]], 
                            category_suggestions: List[Dict[str, Any]]) -> str:
    """Format suggestions into a readable message"""
    message_parts = []
    
    if item_suggestions:
        items = "\n".join(
            f"• {item['name']} (${item['price']:.2f}) - "
            f"ordered together {item['times_ordered_together']} times "
            f"({item['percentage_of_orders']}% of orders)"
            for item in item_suggestions
        )
        message_parts.append(f"Suggested items:\n{items}")
    
    if category_suggestions:
        categories = "\n".join(
            f"• {cat['name']} - appears in {cat['percentage_of_orders']}% "
            f"of orders with popular items: {', '.join(cat['popular_items'][:3])}"
            for cat in category_suggestions
        )
        message_parts.append(f"Suggested categories:\n{categories}")
    
    return "\n\n".join(message_parts) if message_parts else "No suggestions available"

```

## API Functions

```python
import json
import requests
from utils.config import OPENAI_API_KEY, AI_MODEL
from utils.database_functions import (
    ask_postgres_database,
    get_db_connection,
    execute_menu_update
)
from tenacity import retry, wait_random_exponential, stop_after_attempt



@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))
def send_api_request_to_openai_api(messages, functions=None, function_call=None, model=AI_MODEL, openai_api_key=OPENAI_API_KEY):
    """ Send the API request to the OpenAI API via Chat Completions endpoint """
    try:
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {openai_api_key}"}
        json_data = {"model": model, "messages": messages}
        if functions: 
            json_data.update({"functions": functions})
        if function_call: 
            json_data.update({"function_call": function_call})
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, json=json_data)
        response.raise_for_status()

        return response
    
    except requests.RequestException as e:
        raise ConnectionError(f"Failed to connect to OpenAI API due to: {e}")


def execute_function_call(message):
    """ Run the function call provided by OpenAI's API response """
    try:
        function_name = message["function_call"]["name"]
        arguments = json.loads(message["function_call"]["arguments"])
        
        if function_name == "ask_postgres_database":
            query = arguments["query"]
            print(f"SQL query: {query} \n")
            results = ask_postgres_database(get_db_connection, query)
            print(f"Results A: {results} \n")
            
        elif function_name == "toggle_menu_item":
            query = arguments["query"]
            conn = get_db_connection()
            try:
                results = execute_menu_update(conn, query, "toggle_menu_item")
            finally:
                if conn:
                    conn.close()
            
        else:
            results = f"Error: function {function_name} does not exist"
            
        return results
        
    except Exception as e:
        return f"Error executing {message['function_call']['name']}: {str(e)}"


```

## Business Rules

```python
"""
Business rules and definitions for the application.
Each category of rules is organized in its own dictionary for clarity and maintainability.
"""

# Order Status Definitions
ORDER_STATUS = {
    0: "Open",
    6: "Cancelled",
    7: "Completed"
    # Add more statuses as needed
}
# # Order Type Definitions
# ORDER_TYPE = {
#     1: "Delivery",
#     2: "Pickup", 
#     3: "Dine-in",
#     # Add more types as needed
# }

# # Payment Status Definitions
# PAYMENT_STATUS = {
#     1: "Pending",
#     2: "Authorized",
#     3: "Captured",
#     4: "Failed",
#     5: "Refunded",
#     # Add more payment statuses as needed
# }

# Order Filters - Common query conditions
ORDER_FILTERS = {
    "active": "status NOT IN (6, 7, 8)",  # Not cancelled, completed, or refunded
    "completed": "status = 7",
    "cancelled": "status = 6",
    "refunded": "status = 8",
    "in_progress": "status IN (2, 3, 4, 5)",  # Confirmed through In Transit
    # Add more filters as needed
}

# Time Periods - Common time ranges for queries
TIME_PERIODS = {
    "today": "(created_at - INTERVAL '7 hours')::date = CURRENT_DATE",
    "yesterday": "(created_at - INTERVAL '7 hours')::date = CURRENT_DATE - INTERVAL '1 day'",
    "this_week": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '7 days'",
    "this_month": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '30 days'",
    "last_hour": "created_at >= NOW() - INTERVAL '1 hour'",
    "last_24_hours": "created_at >= NOW() - INTERVAL '24 hours'",
    "last_week": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '7 days' AND (created_at - INTERVAL '7 hours')::date < CURRENT_DATE",
    "last_month": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '30 days' AND (created_at - INTERVAL '7 hours')::date < CURRENT_DATE",
    "last_quarter": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '90 days'",
    "last_year": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '365 days'",
    "this_year": "EXTRACT(year FROM (created_at - INTERVAL '7 hours')) = EXTRACT(year FROM CURRENT_DATE)",
    "current_week": "EXTRACT(week FROM (created_at - INTERVAL '7 hours')) = EXTRACT(week FROM CURRENT_DATE)",
    "current_month": "EXTRACT(month FROM (created_at - INTERVAL '7 hours')) = EXTRACT(month FROM CURRENT_DATE)",
    "current_quarter": "EXTRACT(quarter FROM (created_at - INTERVAL '7 hours')) = EXTRACT(quarter FROM CURRENT_DATE)",
    "previous_week": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '14 days' AND (created_at - INTERVAL '7 hours')::date < CURRENT_DATE - INTERVAL '7 days'",
    "previous_month": "(created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '60 days' AND (created_at - INTERVAL '7 hours')::date < CURRENT_DATE - INTERVAL '30 days'"
}

# Status Transitions - Valid status changes
STATUS_TRANSITIONS = {
    1: [2, 6],        # Pending -> Confirmed or Cancelled
    2: [3, 6],        # Confirmed -> In Progress or Cancelled
    3: [4, 6],        # In Progress -> Ready or Cancelled
    4: [5, 6, 7],     # Ready -> In Transit, Cancelled, or Completed
    5: [6, 7],        # In Transit -> Cancelled or Completed
    6: [],            # Cancelled -> No further transitions
    7: [8],           # Completed -> Can only be Refunded
    8: []             # Refunded -> No further transitions
}

def is_valid_status_transition(current_status: int, new_status: int) -> bool:
    """Check if a status transition is valid"""
    if current_status not in STATUS_TRANSITIONS:
        return False
    return new_status in STATUS_TRANSITIONS[current_status]

def get_status_name(status_code: int) -> str:
    """Get the human-readable name for a status code"""
    return ORDER_STATUS.get(status_code, "Unknown Status")


def build_status_filter(statuses: list) -> str:
    """Build a SQL WHERE clause for multiple statuses"""
    if not statuses:
        return ""
    return f"status IN ({','.join(map(str, statuses))})"

def build_time_filter(period: str) -> str:
    """Get the SQL condition for a time period"""
    return TIME_PERIODS.get(period, TIME_PERIODS["today"]) 
```

## Chat Functions

```python
import tiktoken
import streamlit as st
import json
from typing import Dict, List, Any
from utils.config import AI_MODEL
from utils.api_functions import send_api_request_to_openai_api, execute_function_call
from utils.operation_patterns import match_operation, handle_operation_step
from utils.database_functions import (
    execute_menu_update as db_execute_menu_update,
    get_db_connection,
    execute_menu_query
)
from utils.menu_analytics import (
    get_recent_operations,
    get_popular_items,
    analyze_time_patterns,
    get_category_relationships
)
import logging
import datetime
import os
from pathlib import Path
from utils.create_sql_statement import generate_sql_from_user_query  # Import our Gemini SQL generator
import requests

# Create logs directory if it doesn't exist
log_dir = Path("logs")
log_dir.mkdir(exist_ok=True)

# Clear existing handlers to prevent duplicate logging
logging.getLogger().handlers.clear()

# Get current timestamp for the log file
current_time = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
log_file = f"logs/openai_chat_{current_time}.log"

# Set up logging to both file and console
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        # File handler - new file each run with timestamp
        logging.FileHandler(
            filename=log_file,
            mode='w',  # 'w' mode overwrites the file each time
            encoding='utf-8'
        ),
        # Console handler
        logging.StreamHandler()
    ]
)

# Start the log file with a header
logger = logging.getLogger(__name__)
logger.info(f"=== New Session Started at {current_time} ===")
logger.info("Logging initialized with fresh log file")

# At the top of the file
import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Create a file handler
handler = logging.FileHandler('chat_functions.log')
handler.setLevel(logging.INFO)

# Create a logging format
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

# Add the handler to the logger
logger.addHandler(handler)

def log_openai_interaction(messages: List[Dict], response: Any, interaction_type: str):
    """Log OpenAI interactions with timestamps"""
    timestamp = datetime.datetime.now().isoformat()
    log_entry = {
        "timestamp": timestamp,
        "type": interaction_type,
        "messages": messages,
        "response": response.model_dump() if hasattr(response, 'model_dump') else str(response)
    }
    
    # Pretty print the log entry
    formatted_log = (
        f"\n{'='*80}\n"
        f"INTERACTION TYPE: {interaction_type}\n"
        f"TIMESTAMP: {timestamp}\n"
        f"MESSAGES:\n{json.dumps(messages, indent=2)}\n"
        f"RESPONSE:\n{json.dumps(log_entry['response'], indent=2)}\n"
        f"{'='*80}\n"
    )
    
    logger.info(formatted_log)

def execute_order_query(query: str) -> str:
    """
    Helper function to execute a read-only order query.
    Returns the JSON-dumped result or an error message.
    """
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(query)
        result = cur.fetchall()
        return json.dumps(result, indent=2, default=str)
    except Exception as e:
        logger.error(f"Error executing query: {e}", exc_info=True)
        return f"Error executing query: {str(e)}"
    finally:
        if conn:
            conn.close()

def process_chat_message(message: str, history: List[Dict], functions: List[Dict]) -> Dict:
    """Process chat message with error handling
    
    Args:
        message: User message
        history: Chat history
        functions: OpenAI function definitions
        
    Returns:
        Response dict with role and content
    """
    try:
        # Check for operation in progress
        if "current_operation" in st.session_state:
            operation = st.session_state["current_operation"]
            step = operation["steps"][operation["current_step"]]
            response = handle_operation_step(operation, message)
            
            if response:
                if response["role"] == "function":
                    try:
                        # Execute operation
                        result = execute_menu_update(
                            get_db_connection,
                            response["params"]["query"],
                            operation["type"]
                        )
                        # Clear operation state
                        del st.session_state["current_operation"]
                        return {"role": "assistant", "content": result}
                    except Exception as e:
                        return {"role": "assistant", "content": f"Error executing operation: {str(e)}. Please try again."}
                else:
                    operation["current_step"] += 1
                    st.session_state["current_operation"] = operation
                    return response
        
        # Try to match new operation
        if operation := match_operation(message):
            operation["current_step"] = 0
            st.session_state["current_operation"] = operation
            return handle_operation_step(operation, message)
        
        # Fallback to OpenAI
        try:
            response = send_api_request_to_openai_api(
                history + [{"role": "user", "content": message}],
                functions
            )
            response_json = response.json()
            
            if not response_json.get("choices"):
                return {"role": "assistant", "content": "I encountered an error processing your request. Please try again."}
                
            assistant_message = response_json["choices"][0]["message"]
            
            if assistant_message["role"] == "assistant":
                if assistant_message.get("function_call"):
                    try:
                        results = execute_function_call(assistant_message)
                        return {"role": "assistant", "content": results}
                    except Exception as e:
                        return {"role": "assistant", "content": f"Error executing operation: {str(e)}. Please try again."}
                return assistant_message
            
            return {"role": "assistant", "content": "I encountered an unexpected response. Please try again."}
            
        except Exception as e:
            return {"role": "assistant", "content": f"Error communicating with AI: {str(e)}. Please try again."}
            
    except Exception as e:
        return {"role": "assistant", "content": f"I encountered an error: {str(e)}. Please try again."}

def process_query_results(result: dict, xai_client: dict, user_question: str) -> str:
    """Process query results using XAI API"""
    try:
        data = result.get("results", [])
        prompt = (
            "You are a data translator. Convert these database results into a natural language answer.\n\n"
            "Example 1:\n"
            "Input: [{'count': 3}]\n"
            "Output: There were 3 orders completed yesterday.\n\n"
            "Example 2:\n"
            "Input: [{'sum': 149.99}]\n"
            "Output: The total revenue last month was $149.99.\n\n"
            "Now, convert the following data into a natural language answer:\n"
            f"{json.dumps(data)}\n"
            f"User question: {user_question}"
        )
        
        response = requests.post(
            xai_client['XAI_API_URL'],
            json={
                "messages": [{"role": "user", "content": prompt}],
                "model": xai_client['XAI_MODEL'],
                "temperature": 0.3
            },
            headers={
                "Authorization": f"Bearer {xai_client['XAI_TOKEN']}",
                "Content-Type": "application/json"
            }
        )
        response.raise_for_status()
        summary_response = response.json()['choices'][0]['message']['content']
        summary_content = summary_response.get('content', summary_response)  # Extract inner content
        
        return {"role": "assistant", "content": f"{summary_content}"}
        
    except Exception as e:
        logger.error(f"XAI summarization failed: {str(e)}")
        return f"Found {len(data)} matching records: {data}"

def run_chat_sequence(messages: List[Dict[str, str]], functions: List[Dict[str, Any]], openai_client, grok_client) -> Dict[str, str]:
    """
    Process a chat sequence with function calling:
    1. Categorize the user's request.
    2. Execute appropriate function based on request type.
    3. Handle queries by transforming the user query into SQL using Gemini and then summarizing results.
    """
    user_message = messages[-1]["content"] if messages else ""
    
    logger = logging.getLogger(__name__)
    logger.info(f"\n{'='*50}\nNew Chat Request: {user_message}\n{'='*50}")
    
    try:
        # For example, checking if a location is selected (your logic might vary)
        location_id = 62  # For demonstration; in practice, use the real location_id from session state.
        if not location_id:
            return {"role": "assistant", "content": "Please select a location first to view order information."}
        
        # Categorize user request by calling the categorization function (as you already do)
        categorize_functions = [f for f in functions if f["name"] == "categorize_request"]
        categorize_response = openai_client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=messages,
            functions=categorize_functions,
            function_call={"name": "categorize_request"}
        )
        
        # Log the OpenAI interaction for categorization
        logger.info("Received categorization response.")
        assistant_message = categorize_response.choices[0].message
        if assistant_message.function_call:
            args = json.loads(assistant_message.function_call.arguments)
            request_type = args.get("request_type", "unknown")
            order_metric = args.get("order_metric")
            logger.info(f"Request type: {request_type}")
            
            # ------------------------------
            # Query Handling via Gemini
            # ------------------------------
            if request_type in ["query_orders", "query_menu"]:
                # Generate SQL query using Gemini
                sql_query = generate_sql_from_user_query(user_message, location_id)
                
                logger.info(f"Generated SQL query via Gemini: {sql_query}")
                
                # Execute the SQL query
                result = execute_menu_query(sql_query)
                
                logger.info(f"Raw SQL results: {json.dumps(result)}")
                
                # Only show raw results if debugging mode is active
                raw_response = ""  # Initialize first
                if st.session_state.get("debug_mode"):
                    raw_response = f"Raw results: {json.dumps(result['results'])}"
                
                # Process and summarize the results using Grok
                summary = process_query_results(result, grok_client, user_message)
                summary_content = summary.get('content', summary)  # Extract inner content
                
                final_response = f"{summary_content}"
                if raw_response:
                    final_response += f"\n\n{raw_response}"
                
                logger.info(f"Combined response: {final_response}")
                return {"role": "assistant", "content": final_response}
            
            # ------------------------------
            # Query Handling with Preset Order Metrics
            # (Your already-implemented branches based on specific metrics)
            # ------------------------------
            elif request_type == "query_orders" and order_metric == "completed_orders" and args.get("date"):
                query = f"""
                    SELECT COUNT(*) as completed_orders
                    FROM orders
                    WHERE location_id = {location_id}
                      AND status = 7  -- Assuming 7 means 'Completed'
                      AND DATE(created_at) = '{args.get("date")}';
                """
                logger.info(f"Executing query: {query}")
                result = execute_menu_query(query)
                if result["success"] and result["results"]:
                    completed_orders = result["results"][0].get("completed_orders", 0)
                    response = f"There were {completed_orders} orders completed on {args.get('date')} for location ID {location_id}."
                    logger.info(f"Final response: {response}")
                    return {"role": "assistant", "content": response}
                else:
                    error_msg = f"No data found for location #{location_id} on {args.get('date')}."
                    logger.warning(error_msg)
                    return {"role": "assistant", "content": error_msg}
            
            # ------------------------------
            # Menu Updates (e.g., price changes, enable/disable)
            # ------------------------------
            elif request_type in ["update_price", "disable_item", "enable_item"]:
                # The existing approach: Construct UPDATE queries and execute them.
                if request_type == "update_price" and args.get("item_name") and args.get("new_price") is not None:
                    sql_query = f"""
                        UPDATE items 
                        SET price = {args['new_price']} 
                        WHERE name ILIKE '%{args['item_name']}%' 
                            AND deleted_at IS NULL 
                            AND price >= 0;
                    """
                    return execute_menu_update(messages, functions, sql_query, "update_menu_item", openai_client)
                elif request_type == "disable_item" and args.get("item_name"):
                    sql_query = f"UPDATE items SET disabled = true WHERE name ILIKE '%{args['item_name']}%';"
                    return execute_menu_update(messages, functions, sql_query, "toggle_menu_item", openai_client)
                elif request_type == "enable_item" and args.get("item_name"):
                    sql_query = f"UPDATE items SET disabled = false WHERE name ILIKE '%{args['item_name']}%';"
                    return execute_menu_update(messages, functions, sql_query, "toggle_menu_item", openai_client)
            
            # ------------------------------
            # Fallback / Help Message
            # ------------------------------
            else:
                help_message = (
                    "I'm not quite sure what you'd like to do. Here are the actions I can help with:\n\n"
                    "• Update prices (e.g., 'Update the price of French Fries to 9.99')\n"
                    "• Disable menu items (e.g., 'Disable the Chicken Wings')\n"
                    "• Enable menu items (e.g., 'Enable the Caesar Salad')\n"
                    "• Query orders/menu (e.g., 'Show today's orders' or 'Query the menu')\n\n"
                    "Could you please rephrase your request?"
                )
                return {"role": "assistant", "content": help_message}
        else:
            return {"role": "assistant", "content": "Sorry, I couldn't determine your request. Could you please rephrase?"}
    
    except Exception as e:
        logger.error(f"Error in chat sequence: {str(e)}", exc_info=True)
        return {"role": "assistant", "content": "Sorry, I encountered an error. Please try again or contact support."}

def execute_menu_update(messages: List[Dict[str, str]], 
                       functions: List[Dict[str, Any]], 
                       sql_query: str, 
                       function_name: str,
                       openai_client) -> Dict[str, str]:
    """Helper function to execute menu updates with the appropriate function"""
    try:
        # Get database connection
        conn = get_db_connection()
        
        # Execute the update query
        result = db_execute_menu_update(conn, sql_query, operation_name=function_name)
        
        if "successful" in result.lower():
            # Customize message based on operation type
            if function_name == "update_menu_item":
                return {
                    "role": "assistant",
                    "content": f"✅ Successfully updated the price. {result}"
                }
            elif function_name == "toggle_menu_item":
                action = "enabled" if "disabled = false" in sql_query else "disabled"
                return {
                    "role": "assistant",
                    "content": f"✅ Successfully {action} the menu item. {result}"
                }
        else:
            operation_type = "price update" if function_name == "update_menu_item" else "status update"
            return {
                "role": "assistant",
                "content": f"❌ Failed to perform {operation_type}: {result}"
            }
            
    except Exception as e:
        print(f"Database error: {e}")
        operation_type = "price update" if function_name == "update_menu_item" else "status update"
        return {
            "role": "assistant",
            "content": f"❌ Sorry, I encountered a database error during {operation_type}: {str(e)}"
        }
    finally:
        if conn:
            conn.close()

def clear_chat_history():
    """ Clear the chat history stored in the Streamlit session state """
    del st.session_state["live_chat_history"]
    del st.session_state["full_chat_history"]
    del st.session_state["api_chat_history"]


def count_tokens(text):
    """ Count the total tokens used in a text string """
    if not isinstance(text, str):  
        return 0 
    encoding = tiktoken.encoding_for_model(AI_MODEL)
    total_tokens_in_text_string = len(encoding.encode(text))
    
    return total_tokens_in_text_string


def prepare_sidebar_data(database_schema_dict):
    """ Add a sidebar for visualizing the database schema objects  """
    sidebar_data = {}
    for table in database_schema_dict:
        schema_name = table["schema_name"]
        table_name = table["table_name"]
        columns = table["column_names"]

        if schema_name not in sidebar_data:
            sidebar_data[schema_name] = {}

        sidebar_data[schema_name][table_name] = columns
    return sidebar_data

def call_grok(prompt: str) -> str:
    """Make a call to the XAI Grok API"""
    try:
        # Get environment variables
        xai_token = os.getenv('XAI_TOKEN')
        xai_url = os.getenv('XAI_API_URL')
        xai_model = os.getenv('XAI_MODEL')
        
        # Validate configuration
        if not all([xai_token, xai_url, xai_model]):
            raise ValueError("Missing XAI environment variables")
        
        # Construct the payload
        payload = {
            "messages": [
                {"role": "system", "content": "You are a helpful assistant that converts database results into natural language answers."},
                {"role": "user", "content": prompt}
            ],
            "model": xai_model,
            "temperature": 0.3,
            "stream": False
        }
        
        # Make the API call
        response = requests.post(
            xai_url,
            json=payload,
            headers={
                "Authorization": f"Bearer {xai_token}",
                "Content-Type": "application/json"
            }
        )
        response.raise_for_status()
        
        return response.json()['choices'][0]['message']['content']
        
    except Exception as e:
        logger.error(f"XAI API call failed: {str(e)}")
        return None


```

## Configuration

```python
import os 
from dotenv import load_dotenv


load_dotenv()


# Set up Postgres database credentials
db_credentials = {
    "dbname": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"), 
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_SERVER"),
    "port": os.getenv("DB_PORT")
}

# Set up OpenAI variables 
OPENAI_API_KEY  =   os.getenv("OPENAI_API_KEY")
AI_MODEL        =   'gpt-4o-mini'
# AI_MODEL        =   'gpt-4'



# Max number of tokens permitted within a conversation exchange via OpenAI API
MAX_TOKENS_ALLOWED      =   4000


# Max number of messages to exchange with OpenAI API
MAX_MESSAGES_TO_OPENAI  =   10



# An arbitrary number to provide a buffer to avoid reaching exact token limits
TOKEN_BUFFER            =   200  

```

## Create SQL Statement

```python
import os
import sys
import google.generativeai as genai
from dotenv import load_dotenv
from utils.example_queries import EXAMPLE_QUERIES

def load_schema():
    """Load the database schema from the markdown file"""
    try:
        with open('assets/database_schema.md', 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print("Error: database_schema.md not found in assets directory")
        sys.exit(1)

def create_prompt(schema: str, user_query: str) -> str:
    """Create a prompt for Gemini combining the schema and user query"""
    return f"""You are an expert SQL developer. When generating queries:
1. Always include location_id = [ACTUAL_LOCATION_ID] in WHERE clauses
2. Maintain date filters from previous context
3. Use explicit JOINs instead of implicit joins
4. Handle currency values as DECIMAL/NUMERIC types
5. Always include order status = 7 for completed orders

Database Schema (PostgreSQL):
{schema}

Example queries show proper filtering:
- Always filter by location_id
- Completed orders use status = 7
- Date filters use (created_at - INTERVAL '7 hours')::date

User Question: {user_query}

Generate a properly filtered SQL query that:
1. Includes location_id = [ACTUAL_LOCATION_ID]
2. Filters to status = 7 when asking about completed orders
3. Maintains date filters from the conversation context
4. Uses explicit JOINs with proper aliases
"""

def generate_sql_query(prompt: str, model):
    """Generate SQL query using Gemini"""
    try:
        response = model.generate_content(prompt)
        if response.text:
            # Remove any markdown code block syntax
            sql_query = response.text.strip()
            sql_query = sql_query.replace('```sql', '').replace('```', '').strip()
            return sql_query
        else:
            return "Error: No response generated"
    except Exception as e:
        return f"Error generating SQL query: {str(e)}"

def generate_sql_from_user_query(user_query: str, location_id: int) -> str:
    """
    Uses Gemini AI to generate an SQL statement based on the user's query and location ID.
    """
    schema = load_schema()
    prompt = create_prompt(schema, user_query)
    
    # Setup Gemini
    api_key = os.getenv("GOOGLE_GEMINI_API")
    model_id = os.getenv("GOOGLE_GEMINI_MODEL", "gemini-pro")
    
    if not api_key:
        raise Exception("Error: GOOGLE_GEMINI_API environment variable not set.")
    
    genai.configure(api_key=api_key)
    model = genai.GenerativeModel(model_id)
    
    generated_sql = generate_sql_query(prompt, model)
    
    # Replace [ACTUAL_LOCATION_ID] placeholder with actual location ID
    generated_sql = generated_sql.replace("[ACTUAL_LOCATION_ID]", str(location_id))
    
    # Validate that the placeholder was replaced
    if "[ACTUAL_LOCATION_ID]" in generated_sql:
        raise ValueError("Location ID placeholder was not replaced in generated SQL")
    
    return generated_sql

def main():
    # Load environment variables
    load_dotenv()
    
    print("\nSQL Query Generator")
    print("------------------")
    print("Type 'exit' to quit")
    print("Enter your question about the database:\n")
    
    while True:
        # Get user input
        user_query = input("> ").strip()
        
        # Check for exit command
        if user_query.lower() in ['exit', 'quit']:
            print("\nGoodbye!")
            break
        
        if not user_query:
            continue
            
        print("\nGenerating SQL query...\n")
        sql_query = generate_sql_from_user_query(user_query, 1)  # Assuming location_id is 1
        print(sql_query)
        print("\n" + "-"*50 + "\n")

if __name__ == "__main__":
    main() 
```

## Database Functions

```python
import psycopg2
import re
import json
import streamlit as st
from utils.config import db_credentials
from utils.menu_operations import add_operation_to_history
from utils.query_templates import QUERY_TEMPLATES
from decimal import Decimal
from typing import Dict, Any
import psycopg2.extras
from psycopg2.extras import DictCursor
import os

def get_db_connection():
    """Get database connection"""
    try:
        conn = psycopg2.connect(**db_credentials, cursor_factory=DictCursor)
        conn.set_session(autocommit=True)
        return conn
    except Exception as e:
        raise ConnectionError(f"Unable to connect to the database due to: {e}")

def get_database_info(connection, schema_names):
    """ Fetches information about the schemas, tables and columns in the database """
    table_dicts = []
    for schema in schema_names:
        for table_name in get_table_names(connection, schema):
            column_names = get_column_names(connection, table_name, schema)
            table_dicts.append({"table_name": table_name, "column_names": column_names, "schema_name": schema})
    return table_dicts

def get_schema_names(database_connection):
    """ Returns a list of schema names """
    cursor = database_connection.cursor()
    cursor.execute("SELECT schema_name FROM information_schema.schemata;")
    schema_names = [row[0] for row in cursor.fetchall()]
    cursor.close()
    return schema_names

def get_table_names(connection, schema_name):
    """ Returns a list of table names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT table_name FROM information_schema.tables WHERE table_schema = '{schema_name}';")
    table_names = [table[0] for table in cursor.fetchall()]
    cursor.close()
    return table_names

def get_column_names(connection, table_name, schema_name):
    """ Returns a list of column names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}' AND table_schema = '{schema_name}';")
    column_names = [col[0] for col in cursor.fetchall()]
    cursor.close()
    return column_names

# Initialize database schema dict
database_schema_dict = []

# Initialize database functions
def init_db():
    """Initialize database connection"""
    try:
        conn = get_db_connection()
        if conn and not conn.closed:
            print(f"Connected successfully to {db_credentials['dbname']} database")
            return True
        return False
    except Exception:
        return False

# Database schema info
def get_schema_info():
    """Get database schema information"""
    conn = get_db_connection()
    schemas = ['public']
    database_schema_dict = get_database_info(conn, schemas)
    return "\n".join(
        [
            f"Schema: {table['schema_name']}\nTable: {table['table_name']}\nColumns: {', '.join(table['column_names'])}"
            for table in database_schema_dict
        ]
    )

# Initialize schema string
database_schema_string = ""

def init_schema():
    """Initialize database schema information"""
    global database_schema_dict, database_schema_string
    try:
        conn = get_db_connection()
        schemas = ['public']
        database_schema_dict = get_database_info(conn, schemas)
        database_schema_string = get_schema_info()
        conn.close()
    except Exception as e:
        print(f"Error initializing database schema: {e}")
        database_schema_dict = []
        database_schema_string = ""

def ask_postgres_database(connection, query):
    """ Execute the SQL query provided by OpenAI and return the results """
    try:
        with connection.cursor() as cursor:
            cursor.execute(query)
            results = str(cursor.fetchall())
        return results
    except Exception as e:
        return f"Query failed with error: {e}"

def get_location_settings(connection, location_id):
    """Get location settings including common operations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT settings FROM locations WHERE id = %s", (location_id,))
            result = cursor.fetchone()
        return json.loads(result[0]) if result and result[0] else {}
    except Exception as e:
        return f"Failed to get location settings: {e}"

def update_location_settings(connection, location_id, settings):
    """Update location settings"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("UPDATE locations SET settings = %s WHERE id = %s", 
                         (json.dumps(settings), location_id))
        return "Settings updated successfully"
    except Exception as e:
        return f"Failed to update settings: {e}"

def extract_item_id(query):
    """Extract item ID from update query"""
    match = re.search(r'WHERE\s+(?:items\.)?id\s*=\s*(\d+)', query, re.IGNORECASE)
    if not match:
        raise ValueError("Update queries must include item ID in WHERE clause")
    return int(match.group(1))

def validate_time_range(time_str):
    """Validate time range format (0000-2359)"""
2[0-3])([0-5]\d)$', time_str):
        raise ValueError("Time must be in 24-hour format (0000-2359)")
    return True

def execute_menu_update(connection, query, operation_name=None):
    """Execute menu update with row-level locking and validation"""
    try:
        with connection:  # Auto-commits or rolls back
            with connection.cursor() as cursor:
                # Set transaction isolation level
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Extract and validate item ID for item updates
                item_id = None
                if "UPDATE items" in query.lower():
                    item_id = extract_item_id(query)
                    # Acquire row-level lock
                    cursor.execute("SELECT * FROM items WHERE id = %s FOR UPDATE", (item_id,))
                    
                    # Validate query plan
                    cursor.execute("EXPLAIN " + query)
                    plan = cursor.fetchall()
                    if not any('Index Scan' in str(row) for row in plan):
                        raise ValueError("Query must use index for updates")
                
                # Validate price updates
                if "UPDATE items SET price" in query.lower():
                    cursor.execute("SELECT COUNT(*) FROM (" + query.replace(";", "") + ") as q WHERE price < 0")
                    if cursor.fetchone()[0] > 0:
                        raise ValueError("Price updates must be non-negative")
                
                # Validate time ranges
                if "UPDATE categories" in query.lower() and ("start_time" in query or "end_time" in query):
end)_time\s*=\s*(\d{4})', query, re.IGNORECASE)
                    for time_str in time_matches:
                        validate_time_range(time_str)
                
                # Execute update
                cursor.execute(query)
                affected = cursor.rowcount
                
                # Record operation in history if name provided
                if operation_name and "location_id" in st.session_state:
                    settings = get_location_settings(connection, st.session_state["location_id"])
                    settings = add_operation_to_history(settings, {
                        "operation_type": "update",
                        "operation_name": operation_name,
                        "query_template": query,
                        "result_summary": f"Updated {affected} rows"
                    })
                    update_location_settings(connection, st.session_state["location_id"], settings)
                
                return f"Update successful. {affected} rows affected."
    except Exception as e:
        # Transaction will automatically rollback
        return f"Update failed: {e}"

def execute_template_query(connection, template_name: str, params: dict):
    """Execute a predefined query template"""
    try:
        with connection.cursor() as cursor:
            query = QUERY_TEMPLATES[template_name]
            cursor.execute(query, params)
            if template_name.startswith('select'):
                return cursor.fetchall()
            return f"{cursor.rowcount} rows affected"
    except Exception as e:
        return f"Query failed: {e}"

def get_location_hours(connection, location_id: int):
    """Get location hours using template"""
    return execute_template_query(
        connection,
        "view_location_hours",
        {"location_id": location_id}
    )

def update_location_hours(connection, location_id: int, day_of_week: str, 
                        open_time: str, close_time: str):
    """Update location hours using template"""
    return execute_template_query(
        connection,
        "update_location_hours",
        {
            "location_id": location_id,
            "day_of_week": day_of_week,
            "open_time": open_time,
            "close_time": close_time
        }
    )

def get_markers(connection, location_id: int):
    """Get markers using template"""
    return execute_template_query(
        connection,
        "view_markers",
        {"location_id": location_id}
    )

def add_marker(connection, marker_data: dict):
    """Add marker using template"""
    return execute_template_query(
        connection,
        "insert_marker",
        marker_data
    )

def cleanup_menu(connection, location_id: int, item_name: str, option_name: str):
    """Cleanup menu using template"""
    return execute_template_query(
        connection,
        "menu_cleanup",
        {
            "location_id": location_id,
            "item_name": item_name,
            "option_name": option_name
        }
    )

def execute_menu_query(query: str) -> Dict[str, Any]:
    """Execute a read-only menu query and return results"""
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(query)
        
        # Convert Decimal types to float for JSON serialization
        results = [
            {col: float(val) if isinstance(val, Decimal) else val 
             for col, val in row.items()}
            for row in cur.fetchall()
        ]
        
        return {
            "success": True,
            "results": results,
            "columns": [desc[0] for desc in cur.description],
            "query": query
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "query": query
        }
    finally:
        if conn:
            conn.close()

def process_query_results(results):
    """Convert query results to natural language using OpenAI"""
    import openai
    import os
    import json

    if not results["success"]:
        return f"Error executing query: {results['error']}"

    # Prepare context for OpenAI
    context = {
        "query": results["query"],
        "success": results["success"]
    }
    
    if "results" in results:
        context["data"] = results["results"]
        context["columns"] = results["columns"]
        result_type = "query results"
    else:
        context["affected_rows"] = results["affected_rows"]
        result_type = "update results"

    try:
        # Configure OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        model = os.getenv("MODEL_FOR_ANALYSIS", "gpt-3.5-turbo")
        temp = float(os.getenv("ANALYSIS_TEMPERATURE", "0.3"))

        # Create system prompt
        system_prompt = f"""You are a helpful assistant that converts database {result_type} into natural language responses.
For query results, describe what was found in a clear, concise way.
For update results, describe what was changed and how many rows were affected.
Be concise but informative."""

        response = openai.ChatCompletion.create(
            model=model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": json.dumps(context, indent=2)}
            ],
            temperature=temp,
            max_tokens=150
        )
        
        if not response.choices:
            return "Error: No response generated"
            
        return response.choices[0].message["content"]
    except Exception as e:
        return f"Error generating response: {str(e)}"

```

## Example Queries

```python
EXAMPLE_QUERIES = """
Examples of queries used in our project for context:

1. Yesterday's order details:
--------------------------------------------------
SELECT
    l.id,
    l.name as location_name,
    o.id AS order_id,
    o.status AS order_status,
    o.total AS order_total,
    u.id AS user_id,
    u.phone AS user_phone,
    u.email AS user_email,
    o.updated_at - INTERVAL '7 hours' AS order_date,
    o.tip as tip,
    d.amount as discount_amount
FROM orders o
INNER JOIN users u ON o.customer_id = u.id
INNER JOIN locations l ON l.id = o.location_id
LEFT JOIN discounts d on d.order_id = o.id
WHERE l.id = 62
  AND o.status = 7
  AND (o.updated_at - INTERVAL '7 hours')::date = CURRENT_DATE - INTERVAL '1 day';

2. Total sales revenue for the past month:
--------------------------------------------------
SELECT COALESCE(SUM(total), 0) as total_revenue
FROM orders
WHERE location_id = 62
  AND (created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '1 month'
  AND status = 7;

3. This month's sales revenue:
--------------------------------------------------
SELECT COALESCE(SUM(total), 0) as current_month_revenue
FROM orders
WHERE location_id = 62
  AND date_trunc('month', (created_at - INTERVAL '7 hours')) = date_trunc('month', CURRENT_DATE)
  AND status = 7;

4. Same month last year's sales revenue:
--------------------------------------------------
SELECT COALESCE(SUM(total), 0) as last_year_same_month_revenue
FROM orders
WHERE location_id = 62
  AND date_trunc('month', (created_at - INTERVAL '7 hours')) = date_trunc('month', CURRENT_DATE - INTERVAL '1 year')
  AND status = 7;

5. Top 5 menu items by revenue in the past quarter:
--------------------------------------------------
SELECT i.name as menu_item, COUNT(oi.id) as order_count,
       COALESCE(SUM(i.price * oi.quantity), 0) as revenue
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN items i ON oi.item_id = i.id
WHERE o.location_id = 62
  AND (o.created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '3 months'
  AND o.status = 7
GROUP BY i.name
ORDER BY revenue DESC
LIMIT 5;

6. Average order value over the past six months:
--------------------------------------------------
SELECT COALESCE(AVG(total), 0) as avg_order_value
FROM orders
WHERE location_id = 62
  AND (created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '6 months'
  AND status = 7;

7. New customers acquired in the last week:
--------------------------------------------------
WITH first_orders AS (
    SELECT customer_id, MIN((created_at - INTERVAL '7 hours')::date) as first_order_date
    FROM orders
    WHERE location_id = 62
      AND status = 7
    GROUP BY customer_id
)
SELECT COUNT(*) as new_customers
FROM first_orders
WHERE first_order_date >= CURRENT_DATE - INTERVAL '7 days';

8. Percentage of orders from repeat customers:
--------------------------------------------------
WITH customer_orders AS (
    SELECT customer_id, COUNT(*) as order_count
    FROM orders
    WHERE location_id = 62
      AND status = 7
    GROUP BY customer_id
),
repeat_customers AS (
    SELECT customer_id
    FROM customer_orders
    WHERE order_count > 1
)
SELECT 
    (SELECT COUNT(*) FROM orders o 
     WHERE o.location_id = 62 AND o.status = 7 
       AND o.customer_id IN (SELECT customer_id FROM repeat_customers)
    ) * 100.0
    / NULLIF((SELECT COUNT(*) FROM orders o 
              WHERE o.location_id = 62 AND o.status = 7), 0)
    AS repeat_percentage;

9. Peak ordering hours (top 3):
--------------------------------------------------
SELECT EXTRACT(HOUR FROM (created_at - INTERVAL '7 hours')) as order_hour,
       COUNT(*) as order_count
FROM orders
WHERE location_id = 62
GROUP BY order_hour
ORDER BY order_count DESC
LIMIT 3;

10. Days of the week with highest order volume:
--------------------------------------------------
SELECT TRIM(TO_CHAR((created_at - INTERVAL '7 hours'), 'Day')) as order_day,
       COUNT(*) as order_count
FROM orders
WHERE location_id = 62
GROUP BY TRIM(TO_CHAR((created_at - INTERVAL '7 hours'), 'Day'))
ORDER BY order_count DESC;

11. Average fulfillment time (minutes):
--------------------------------------------------
SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at)))/60 
       AS avg_fulfillment_time_minutes
FROM orders
WHERE location_id = 62
  AND status = 7
  AND (updated_at - created_at) BETWEEN INTERVAL '5 minutes' AND INTERVAL '4 hours';

12. Average delivery time (minutes) for app orders:
--------------------------------------------------
SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at)))/60 
       AS avg_delivery_time_minutes
FROM orders
WHERE location_id = 62
  AND status = 7
  AND type = 1
  AND (updated_at - created_at) BETWEEN INTERVAL '5 minutes' AND INTERVAL '4 hours';

13. Average order rating:
--------------------------------------------------
SELECT AVG(value) as avg_rating
FROM order_ratings_feedback;

14. Canceled or refunded orders in the past month:
--------------------------------------------------
SELECT COUNT(*) as canceled_refunded_orders
FROM orders
WHERE location_id = 62
  AND (created_at - INTERVAL '7 hours')::date >= CURRENT_DATE - INTERVAL '1 month'
  AND status IN (6, 8);

15. Most common cancellation reason:
--------------------------------------------------
SELECT instructions as cancellation_reason, COUNT(*) as count
FROM orders
WHERE location_id = 62
  AND status = 6
GROUP BY instructions
ORDER BY count DESC
LIMIT 1;

16. Menu categories with highest sales:
--------------------------------------------------
SELECT c.name as category, COUNT(DISTINCT o.id) as order_count,
       COALESCE(SUM(oi.quantity * i.price), 0) as total_revenue
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN items i ON oi.item_id = i.id
JOIN categories c ON i.category_id = c.id
WHERE o.location_id = 62
  AND o.status = 7
GROUP BY c.name
ORDER BY total_revenue DESC;

17. Average time between first and second order (hours):
--------------------------------------------------
WITH first_two_orders AS (
  SELECT customer_id, created_at,
         ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY created_at) AS order_num
  FROM orders
  WHERE location_id = 62
    AND status = 7
),
first_second AS (
  SELECT customer_id,
         MIN(CASE WHEN order_num = 1 THEN created_at END) AS first_order,
         MIN(CASE WHEN order_num = 2 THEN created_at END) AS second_order
  FROM first_two_orders
  GROUP BY customer_id
)
SELECT AVG(EXTRACT(EPOCH FROM (second_order - first_order)))/3600 
       AS avg_hours_between_first_and_second
FROM first_second
WHERE second_order IS NOT NULL;

18. Lifetime value of our average customer:
--------------------------------------------------
SELECT AVG(total_spent) as avg_lifetime_value
FROM (
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    WHERE location_id = 62
      AND status = 7
    GROUP BY customer_id
) sub;
""" 
```

## Export Code

```python
import os
from datetime import datetime

def create_code_section(title, file_content, language):
    """Create a markdown code section with title and content"""
    return f"## {title}\n\n```{language}\n{file_content}\n```\n\n"

def read_file_content(file_path):
    """Read content from a file, stripping line numbers"""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
content")
')[1] if '            return ''.join(content)
    except Exception as e:
        return f"Error reading file {file_path}: {str(e)}"
def export_codebase_to_markdown():
    # Define the core files to export
    core_files = [
        ("Analytics", "utils/analytics.py", "python"),
        ("API Functions", "utils/api_functions.py", "python"), 
        ("Business Rules", "utils/business_rules.py", "python"),
        ("Chat Functions", "utils/chat_functions.py", "python"),
        ("Configuration", "utils/config.py", "python"),
        ("Create SQL Statement", "utils/create_sql_statement.py", "python"),
        ("Database Functions", "utils/database_functions.py", "python"),
        ("Example Queries", "utils/example_queries.py", "python"),
        ("Export Code", "export_code.py", "python"),
        ("Function Calling Spec", "utils/function_calling_spec.py", "python"),
        ("Helper Functions", "utils/helper_functions.py", "python"),
        ("Menu Analytics", "utils/menu_analytics.py", "python"),
        ("Menu Operations", "utils/menu_operations.py", "python"),
        ("Operation Patterns", "utils/operation_patterns.py", "python"),
        ("Query Templates", "utils/query_templates.py", "python"),
        ("System Prompts", "utils/system_prompts.py", "python"),
        ("UI Components", "utils/ui_components.py", "python")
    ]

    # Create markdown content
    timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
    markdown_content = [
        f"# Menu Updater Codebase Export\n\nGenerated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    ]

    # Add project overview from README
    readme_content = read_file_content("README.md")
    markdown_content.append("# Project Overview\n\n")
    markdown_content.append(readme_content)
    markdown_content.append("\n\n# Source Code\n\n")

    # Add each core file
    for title, file_path, language in core_files:
        content = read_file_content(file_path)
        markdown_content.append(create_code_section(title, content, language))

    # Write to file
    output_dir = "exports"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    output_file = f"{output_dir}/codebase_export_{timestamp}.md"
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(''.join(markdown_content))

    print(f"Codebase exported to: {output_file}")

if __name__ == "__main__":
    export_codebase_to_markdown()
```

## Function Calling Spec

```python
from utils.database_functions import database_schema_string

# Specify function descriptions for OpenAI function calling 
functions = [
    {
        "name": "categorize_request",
        "description": "Analyze the user's message and determine the request type, item name, new price, etc. If no known request type applies, set request_type='unknown'.",
        "parameters": {
            "type": "object",
            "properties": {
                "request_type": {
                    "type": "string",
                    "enum": ["update_price", "disable_item", "enable_item", "query_menu", "query_orders", "unknown"],
                    "description": "The type of request being made"
                },
                "item_name": {
                    "type": "string",
                    "description": "Name of the item referenced, if any"
                },
                "new_price": {
                    "type": "number",
                    "description": "New price if request_type=update_price. Otherwise ignore."
                },
                "time_period": {
                    "type": "string",
                    "description": "Time period for queries (e.g., 'today', 'this week', 'last month')"
                }
            },
            "required": ["request_type"]
        }
    },
    {
        "name": "update_menu_item",
        "description": "Updates menu item properties like price or description.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "SQL query for item updates. Price must be non-negative, and item_name must match the user's intent."
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "toggle_menu_item",
        "description": "Enable or disable a menu item. Sets disabled=true or disabled=false on an item.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "SQL query to update item.disabled. Example: UPDATE items SET disabled = true WHERE name ILIKE '%French Fries%'"
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "query_orders",
        "description": "Query order information from the database including counts and revenue.",
        "parameters": {
            "type": "object",
            "properties": {
                "order_metric": {
                    "type": "string",
                    "enum": ["completed_orders", "daily_sales"],
                    "description": "The specific order metric to query"
                },
                "date": {
                    "type": "string",
                    "format": "date",
                    "description": "Specific date to query orders for, in 'YYYY-MM-DD' format. Required for 'completed_orders' metric."
                },
                "start_date": {
                    "type": "string",
                    "format": "date",
                    "description": "Start date in YYYY-MM-DD format. Required for 'daily_sales' metric."
                },
                "end_date": {
                    "type": "string",
                    "format": "date",
                    "description": "End date in YYYY-MM-DD format. Required for 'daily_sales' metric."
                }
            },
            "required": ["order_metric"]
        }
    }
]

```

## Helper Functions

```python
import os
import datetime



def save_conversation(conversation_history, directory="conversation_history"):
    """
    Save a given conversation history to a markdown file with timestamps.
    """
    # Create the directory if it doesn't exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Get the current date and time for the filename
    current_datetime = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')
    file_path = os.path.join(directory, f"{current_datetime}.md")

    with open(file_path, 'w', encoding='utf-8') as file:
        for message in conversation_history:
            if message["role"] in ["user", "assistant"]:
                message_timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                role_icon = '🧑‍💻' if message["role"] == "user" else '🤖'
                file.write(f"{message_timestamp} **{role_icon} {message['role'].title()}:** {message['content']}\n\n")
    
    return file_path

```

## Menu Analytics

```python
"""Menu analytics functions for AI context"""
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any
from utils.database_functions import get_location_settings

def get_recent_operations(connection, location_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    """Get recent menu operations for a location"""
    try:
        settings = get_location_settings(connection, location_id)
        if isinstance(settings, str):  # Error message returned
            return []
        history = settings.get('operation_history', [])
        return history[:limit]
    except Exception as e:
        return []

def get_popular_items(connection, location_id: int) -> List[Dict[str, Any]]:
    """Get popular menu items based on analytics"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT i.id, i.name, i.price, 
                       a.views, a.orders, a.revenue,
                       a.last_ordered
                FROM items i
                JOIN menu_item_analytics a ON i.id = a.item_id
                JOIN categories c ON i.category_id = c.id
                JOIN menus m ON c.menu_id = m.id
                WHERE m.location_id = %s
                  AND i.disabled = false
                ORDER BY a.orders DESC, a.revenue DESC
                LIMIT 10
            """, (location_id,))
            columns = ['id', 'name', 'price', 'views', 'orders', 'revenue', 'last_ordered']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def analyze_time_patterns(connection, location_id: int) -> Dict[str, Any]:
    """Analyze time-based ordering patterns"""
    try:
        with connection.cursor() as cursor:
            # Get items with time restrictions
            cursor.execute("""
                SELECT c.name as category,
                       c.start_time,
                       c.end_time,
                       COUNT(DISTINCT i.id) as item_count,
                       SUM(a.orders) as total_orders
                FROM categories c
                JOIN items i ON i.category_id = c.id
                JOIN menu_item_analytics a ON i.id = a.item_id
                WHERE c.menu_id IN (
                    SELECT id FROM menus WHERE location_id = %s
                )
                AND c.start_time IS NOT NULL
                GROUP BY c.name, c.start_time, c.end_time
                ORDER BY c.start_time
            """, (location_id,))
            
            patterns = []
            for row in cursor.fetchall():
                patterns.append({
                    'category': row[0],
                    'time_range': f"{row[1]:04d}-{row[2]:04d}",
                    'items': row[3],
                    'orders': row[4]
                })
            
            return {
                'time_based_categories': patterns,
                'analysis_date': datetime.now().isoformat()
            }
    except Exception as e:
        return {'error': str(e)}

def get_category_relationships(connection, location_id: int) -> Dict[str, List[str]]:
    """Get commonly ordered category combinations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                WITH order_categories AS (
                    SELECT DISTINCT o.id as order_id,
                           c.name as category_name
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    JOIN menus m ON c.menu_id = m.id
                    WHERE m.location_id = %s
                ),
                category_pairs AS (
                    SELECT a.category_name as cat1,
                           b.category_name as cat2,
                           COUNT(*) as frequency
                    FROM order_categories a
                    JOIN order_categories b ON a.order_id = b.order_id
                    WHERE a.category_name < b.category_name
                    GROUP BY a.category_name, b.category_name
                    HAVING COUNT(*) >= 5
                    ORDER BY COUNT(*) DESC
                )
                SELECT cat1, cat2, frequency
                FROM category_pairs
                LIMIT 10
            """, (location_id,))
            
            relationships = {}
            for row in cursor.fetchall():
                if row[0] not in relationships:
                    relationships[row[0]] = []
                relationships[row[0]].append({
                    'category': row[1],
                    'frequency': row[2]
                })
            
            return relationships
    except Exception as e:
        return {}

```

## Menu Operations

```python
from datetime import datetime
import psycopg2
from typing import Dict, List, Optional, Tuple, Union

from typing import Dict, List, Any, Tuple, Union

def add_operation_to_history(
    operation_type: str,
    details: Dict,
    status: str,
    connection
) -> None:
    """
    Add an operation to the history table
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            INSERT INTO operation_history 
            (operation_type, operation_details, status, timestamp)
            VALUES (%s, %s, %s, %s)
            """,
            (operation_type, str(details), status, datetime.now())
        )
        connection.commit()
    except Exception as e:
        print(f"Error adding operation to history: {e}")
    finally:
        cursor.close()

def update_menu_item_price(
    item_id: int,
    new_price: float,
    connection
) -> Tuple[bool, str]:
    """
    Update the price of a menu item
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            "UPDATE menu_items SET price = %s WHERE item_id = %s",
            (new_price, item_id)
        )
        connection.commit()
        return True, "Price updated successfully"
    except Exception as e:
        return False, f"Error updating price: {e}"
    finally:
        cursor.close()

def update_category_time_range(
    category_id: int,
    start_time: str,
    end_time: str,
    connection
) -> Tuple[bool, str]:
    """
    Update the time range for a category
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE categories 
            SET available_start_time = %s, available_end_time = %s 
            WHERE category_id = %s
            """,
            (start_time, end_time, category_id)
        )
        connection.commit()
        return True, "Time range updated successfully"
    except Exception as e:
        return False, f"Error updating time range: {e}"
    finally:
        cursor.close()

def update_option_limits(
    option_id: int,
    min_selections: int,
    max_selections: int,
    connection
) -> Tuple[bool, str]:
    """
    Update the minimum and maximum selections for an option group
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE option_groups 
            SET min_selections = %s, max_selections = %s 
            WHERE option_group_id = %s
            """,
            (min_selections, max_selections, option_id)
        )
        connection.commit()
        return True, "Option limits updated successfully"
    except Exception as e:
        return False, f"Error updating option limits: {e}"
    finally:
        cursor.close()

def toggle_menu_item(
    item_name: str,
    disabled: bool = True,
    connection = None
) -> Tuple[bool, str]:
    """Toggle menu item enabled/disabled state
    
    Args:
        item_name: Name of the menu item
        disabled: True to disable, False to enable
        connection: Optional database connection
        
    Returns:
        Tuple of (success, message)
    """
    try:
        # Use existing disable_by_name function for transaction safety
        items = [{"id": None, "name": item_name}]
        success, message = disable_by_name(connection, "Menu Item", items)
        
        if success:
            action = "disabled" if disabled else "enabled"
            return True, f"Successfully {action} menu item: {item_name}"
        # Wrap error message to maintain consistent format
        return False, f"Error toggling menu item: {message.split(': ')[1]}"
        
    except Exception as e:
        return False, f"Error toggling menu item: {str(e)}"

def disable_by_name(
    connection,
    disable_type: str,
    items: List[Dict[str, Any]]
) -> Tuple[bool, str]:
    """Disable items or options by name with transaction safety"""
    # Prepare table name based on type
    if disable_type == "Menu Item":
        table = "items"
    elif disable_type == "Item Option":
        table = "options"
    else:
        table = "option_items"
        
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                    
                # Get IDs for locking
                ids = [item["id"] for item in items]
                id_list = ",".join(str(id) for id in ids)
                
                # Lock rows
                cursor.execute(f"SELECT id FROM {table} WHERE id IN ({id_list}) FOR UPDATE")
                
                # Perform update
                cursor.execute(f"UPDATE {table} SET disabled = true WHERE id IN ({id_list})")
                
                affected = cursor.rowcount
                return True, f"Successfully disabled {affected} {table}"
                
    except Exception as e:
        return False, f"Error disabling {table}: {str(e)}"

def disable_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching items
                cursor.execute("""
                    SELECT i.id, i.name, c.name as category
                    FROM items i
                    JOIN categories c ON i.category_id = c.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND i.deleted_at IS NULL
                    AND i.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                items = cursor.fetchall()
                
                if not items:
                    return False, f"No active items found matching '{pattern}'"
                    
                # Format items for confirmation
                items_str = "\n".join(f"- {item[1]} (in {item[2]})" for item in items)
                
                # Disable matching items
                cursor.execute("""
                    UPDATE items 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([item[0] for item in items],))
                
                return True, f"Disabled {len(items)} items:\n{items_str}"
                
    except Exception as e:
        return False, f"Error disabling items: {str(e)}"

def disable_options_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable options for items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching options
                cursor.execute("""
                    SELECT o.id, o.name, i.name as item
                    FROM options o
                    JOIN items i ON o.item_id = i.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND o.deleted_at IS NULL
                    AND o.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                options = cursor.fetchall()
                
                if not options:
                    return False, f"No active options found for items matching '{pattern}'"
                    
                # Format options for confirmation
                options_str = "\n".join(f"- {option[1]} (for {option[2]})" for option in options)
                
                # Disable matching options
                cursor.execute("""
                    UPDATE options 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([option[0] for option in options],))
                
                return True, f"Disabled {len(options)} options:\n{options_str}"
                
    except Exception as e:
        return False, f"Error disabling options: {str(e)}"

def disable_option_items_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable option items for items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching option items
                cursor.execute("""
                    SELECT oi.id, oi.name, o.name as option, i.name as item
                    FROM option_items oi
                    JOIN options o ON oi.option_id = o.id
                    JOIN items i ON o.item_id = i.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND oi.deleted_at IS NULL
                    AND oi.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                option_items = cursor.fetchall()
                
                if not option_items:
                    return False, f"No active option items found for items matching '{pattern}'"
                    
                # Format option items for confirmation
                items_str = "\n".join(f"- {item[1]} (in {item[2]} for {item[3]})" for item in option_items)
                
                # Disable matching option items
                cursor.execute("""
                    UPDATE option_items 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([item[0] for item in option_items],))
                
                return True, f"Disabled {len(option_items)} option items:\n{items_str}"
                
    except Exception as e:
        return False, f"Error disabling option items: {str(e)}"

```

## Operation Patterns

```python
"""Operation patterns for menu management"""
from typing import Dict, Optional, Any
from datetime import datetime
import re

# Common operation patterns
COMMON_OPERATIONS = {
    "disable_item": {
        "patterns": [
            r"disable (?:the )?(?:menu )?item(?: )?(.+)",
            r"turn off (?:menu )?item(?: )?(.+)",
            r"deactivate (?:menu )?item(?: )?(.+)"
        ],
        "steps": ["get_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Menu Item"
    },
    "disable_bulk": {
        "patterns": [
            r"disable all (.+)",
        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_by_pattern",
        "type": "Menu Item"
    },
    "disable_bulk": {
        "patterns": [
every) (.+)",
every) (.+)",
every) (.+)"  # Matches bulk disable patterns
        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_by_pattern",
        "type": "Menu Item"
    },
    "disable_bulk_options": {
        "patterns": [
ininin        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_options_by_pattern",
        "type": "Item Option"
    },
    "disable_bulk_option_items": {
        "patterns": [
ininin        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_option_items_by_pattern",
        "type": "Option Item"
    },
    "disable_item": {
        "patterns": [
            r"disable (?:the )?(?:menu )?item",
            r"turn off (?:the )?(?:menu )?item",
            r"deactivate (?:the )?(?:menu )?item"
        ],
        "steps": ["get_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Menu Item"
    },
    "disable_option": {
        "patterns": [
            r"disable (?:the )?(?:menu )?option(?! item)",
            r"turn off (?:the )?(?:menu )?option(?! item)",
            r"deactivate (?:the )?(?:menu )?option(?! item)"
        ],
        "steps": ["get_option_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Item Option"
    },
    "disable_option_item": {
        "patterns": [
            r"disable (?:the )?option item",
            r"turn off (?:the )?option item",
            r"deactivate (?:the )?option item"
        ],
        "steps": ["get_option_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Option Item"
    },
    "update_price": {
        "patterns": [
            r"update (?:the )?price",
            r"change (?:the )?price",
            r"set (?:the )?price"
        ],
        "steps": ["get_item_name", "get_new_price", "confirm_price", "execute_price_update"],
        "function": "update_menu_item_price"
    },
    "update_time_range": {
        "patterns": [
            r"update (?:the )?time range",
            r"change (?:the )?time range",
            r"set (?:the )?time range"
        ],
        "steps": ["get_category_name", "get_start_time", "get_end_time", "confirm_time_range", "execute_time_update"],
        "function": "update_category_time_range"
    }
}


def match_operation(query: str) -> Optional[Dict[str, Any]]:
    """Match query against common operation patterns
    
    Args:
        query: User query string
        
    Returns:
        Dict with operation type and parameters if matched,
        None otherwise
    """
    query_lower = query.lower()
    for op_type, op_data in COMMON_OPERATIONS.items():
        for pattern in op_data["patterns"]:
            if match := re.search(pattern, query_lower):
                operation = {
                    "type": op_type,
                    "steps": op_data["steps"].copy(),
                    "function": op_data["function"],
                    "item_type": op_data.get("type"),
                    "current_step": 0,
                    "params": {}
                }
                if len(match.groups()) > 0:
                    # Extract pattern from original query
                    start, end = match.span(1)
                    original_text = query[start:end]
                    
                    # Handle toggle operations
                    if op_type == "toggle_item":
                        operation_type = "disable"
                        if "enable" in query.lower():
                            operation_type = "enable"
                        elif "toggle" in query.lower():
                            operation_type = "toggle"
                            
                        return {
                            "type": "toggle_item",
                            "steps": ["confirm_items", "confirm_toggle", "execute_toggle"],
                            "function": "toggle_menu_item",
                            "item_type": "Menu Item",
                            "current_step": 0,
                            "params": {
                                "item_name": original_text,
                                "operation": operation_type
                            }
                        }
                    
                    # For options and option items, extract just the item name
                    if "option items" in query.lower():
                        # Extract item name after "for"
                        parts = query.split(" for ")
                        if len(parts) > 1:
                            # Get original case item name
                            item_name = parts[1].strip()
                            return {
                                "type": "disable_bulk_option_items",
                                "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                                "function": "disable_option_items_by_pattern",
                                "item_type": "Option Item",
                                "current_step": 0,
                                "params": {"pattern": item_name}
                            }
                    elif "options" in query.lower():
                        # Extract item name after "for"
                        parts = query.split(" for ")
                        if len(parts) > 1:
                            # Get original case item name
                            item_name = parts[1].strip()
                            return {
                                "type": "disable_bulk_options",
                                "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                                "function": "disable_options_by_pattern",
                                "item_type": "Item Option",
                                "current_step": 0,
                                "params": {"pattern": item_name}
                            }
                    # For regular items
                    return {
                        "type": "disable_bulk",
                        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                        "function": "disable_by_pattern",
                        "item_type": "Menu Item",
                        "current_step": 0,
                        "params": {"pattern": original_text.lower()}
                    }
                return operation
    return None


def handle_operation_step(
    operation: Dict[str, Any], 
    message: str
) -> Dict[str, Any]:
    """Handle operation step including bulk operations
    
    Args:
        operation: Operation dict with type, steps, and params
        message: User message
        
    Returns:
        Dict with response type and content
    """
    # Validate step index
    if operation["current_step"] >= len(operation["steps"]):
        return {"role": "assistant", "content": "I didn't understand that command. Please try again."}
        
    # Convert pattern to lowercase for consistency
    if "pattern" in operation.get("params", {}):
        operation["params"]["pattern"] = operation["params"]["pattern"].lower()
        
    step = operation["steps"][operation["current_step"]]
    # Handle confirmation steps first
    if step == "confirm_disable":
        if message and message.lower() != "yes":
            operation["params"]["item_name"] = message
            return {
                "role": "assistant",
                "content": f"Are you sure you want to disable {message}? (yes/no)"
            }
        if message and message.lower() == "yes":
            return {
                "role": "assistant",
                "content": "Are you absolutely sure? This operation cannot be undone. (yes/no)"
            }
        return {"role": "assistant", "content": "Operation cancelled"}
    
    if step == "confirm_items":
        # For bulk operations, show matching items
        try:
            from utils.menu_operations import (
                disable_by_pattern,
                disable_options_by_pattern,
                disable_option_items_by_pattern
            )
            from utils.database_functions import get_db_connection
            
            pattern = operation["params"]["pattern"]
            conn = get_db_connection()
            
            # Get current state
            if operation["type"] == "disable_bulk":
                success, result = disable_by_pattern(conn, pattern)
            elif operation["type"] == "disable_bulk_options":
                success, result = disable_options_by_pattern(conn, pattern)
            elif operation["type"] == "disable_bulk_option_items":
                success, result = disable_option_items_by_pattern(conn, pattern)
            else:
                return {"role": "assistant", "content": "Invalid operation type"}
                
            if not success:
                return {"role": "assistant", "content": result}
                
            confirmation_msg = (
                f"Found these items:\n{result}\n"
                "Would you like to proceed with disabling them? (yes/no)"
            )
            return {
                "role": "assistant",
                "content": confirmation_msg
            }
            
        except Exception as e:
            return {"role": "assistant", "content": f"Error finding items: {str(e)}"}
    
    elif step.startswith("get_"):
        # Get item/option name or value
        prompts = {
            "get_item_name": "Which menu item?",
            "get_option_name": "Which menu option?",
            "get_option_item_name": "Which option item?",
            "get_new_price": "What should the new price be?",
            "get_category_name": "Which category?",
            "get_start_time": "What should the start time be? (0000-2359)",
            "get_end_time": "What should the end time be? (0000-2359)"
        }
        return {
            "role": "assistant",
            "content": prompts.get(step, "Please provide more information")
        }
        
    elif step.startswith("confirm_"):
        # Confirm operation
        if step in ["confirm_disable", "confirm_toggle"]:
            if message.lower() != "yes":
                return {
                "role": "assistant",
                "content": "Operation cancelled"
            }
            return {
                "role": "assistant",
                "content": "Are you absolutely sure? This operation cannot be undone. (yes/no)"
            }
        else:
            operation["params"]["value"] = message
            confirms = {
                "confirm_price": f"Set price to ${message}? (yes/no)",
                "confirm_time_range": f"Set time range to {operation['params'].get('start_time', '?')}-{message}? (yes/no)"
            }
            prompt = confirms.get(step, "Please confirm (yes/no)")
            return {
                "role": "assistant",
                "content": prompt
            }
        
    elif step.startswith("execute_"):
        # Execute operation if confirmed
        if message.lower() == "yes":
            return {
                "role": "function",
                "name": operation["function"],
                "params": operation["params"]
            }
        else:
            return {
                "role": "assistant",
                "content": "Operation cancelled"
            }
            
    return {
        "role": "assistant",
        "content": "I didn't understand that. Please try again."
    }


def store_operation_history(
    settings: Dict[str, Any], 
    operation: Dict[str, Any], 
    result: Dict[str, Any]
) -> Dict[str, Any]:
    """Store operation in history
    
    Args:
        settings: Location settings dict
        operation: Operation that was executed
        result: Result of the operation
        
    Returns:
        Updated settings dict
    """
    if "operation_history" not in settings:
        settings["operation_history"] = []
        
    history_entry = {
        "type": operation["type"],
        "params": operation["params"],
        "result": result,
        "timestamp": str(datetime.now())
    }
    
    settings["operation_history"].append(history_entry)
    
    # Keep last 50 operations
    if len(settings["operation_history"]) > 50:
        settings["operation_history"] = settings["operation_history"][-50:]
        
    return settings

```

## Query Templates

```python
QUERY_TEMPLATES = {
    "view_location_hours": """
        SELECT * FROM location_hours 
        WHERE location_id = %(location_id)s
    """,
    "update_location_hours": """
        UPDATE location_hours
        SET 
            updated_at = CURRENT_TIMESTAMP,
            open_time = %(open_time)s,
            close_time = %(close_time)s
        WHERE 
            location_id = %(location_id)s
            AND day_of_week = %(day_of_week)s
    """,
    "view_markers": """
        SELECT * FROM markers 
        WHERE location_id = %(location_id)s
        ORDER BY id DESC
    """,
    "insert_marker": """
        INSERT INTO markers 
        (id, created_at, updated_at, deleted_at, name, disabled, location_id)
        VALUES
        (%(id)s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, %(deleted_at)s, 
         %(name)s, %(disabled)s, %(location_id)s)
    """,
    "menu_cleanup": """
        DO $$
        DECLARE
            v_location_id INT := %(location_id)s;
            v_item_name VARCHAR := %(item_name)s;
            v_option_name VARCHAR := %(option_name)s;
        BEGIN
            -- Delete option items first
            DELETE FROM option_items 
            WHERE id IN (
                SELECT DISTINCT oi.id 
                FROM locations l 
                INNER JOIN menus m ON m.location_id = l.id
                INNER JOIN categories c ON c.menu_id = m.id
                INNER JOIN items i ON i.category_id = c.id
                INNER JOIN options o ON o.item_id = i.id
                INNER JOIN option_items oi ON oi.option_id = o.id
                WHERE l.id = v_location_id
                AND i.name = v_item_name
                AND o.name = v_option_name
            );

            -- Then delete the options
            DELETE FROM options 
            WHERE id IN (
                SELECT DISTINCT o.id 
                FROM locations l 
                INNER JOIN menus m ON m.location_id = l.id
                INNER JOIN categories c ON c.menu_id = m.id
                INNER JOIN items i ON i.category_id = c.id
                INNER JOIN options o ON o.item_id = i.id
                WHERE l.id = v_location_id
                AND i.name = v_item_name
                AND o.name = v_option_name
            );
        END $$;
    """
} 
```

## System Prompts

```python
import psycopg2
import streamlit as st
from utils.config import db_credentials


GENERATE_SQL_PROMPT = """
You are Andy, a menu management specialist. Your mission is to help customers query and update their menu items through natural language requests. You understand restaurant operations and help customers maintain their menus efficiently.

Please follow these guidelines for menu operations:
<rules>
1. For menu queries, always join through the proper hierarchy: locations -> menus -> categories -> items
2. When updating prices, ensure values are non-negative and validate before committing
3. For item updates, use the disabled flag instead of deletion to maintain history
4. Maintain option configurations according to min/max constraints (options.min and options.max)
5. Respect time-based menu category constraints (categories.start_time and categories.end_time)
6. Use wildcards like "%keyword%" with LIKE for flexible text matching
7. Present SQL queries in a neat markdown format, like ```sql code```
8. Aim to offer just a single SQL script in one response
9. Guard against SQL injection by cleaning user inputs
10. If a query doesn't yield results, suggest similar menu items or categories
</rules>

Begin with a brief introduction as Andy and offer an overview of available metrics. However, avoid naming every table or schema. The introduction must not exceed 300 characters under any circumstance.

For each SQL output, include a brief rationale, display the outcome, and provide an explanation in context to the user's original request. Always format SQL as {{database}}.{{schema}}.{{table}}.

Before presenting, confirm the validity of SQL scripts and dataframes. Assess if a user's query truly needs a database response. If not, guide them as necessary.

"""


@st.cache_data(show_spinner=False)
def get_table_context(schema: str, table: str, db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute(f"""
    SELECT column_name, data_type FROM information_schema.columns
    WHERE table_schema = '{schema}' AND table_name = '{table}'
    """)
    columns = cursor.fetchall()

    columns_str = "\n".join([f"- **{col[0]}**: {col[1]}" for col in columns])
    context = f"""
    Table: <tableName> {schema}.{table} </tableName>
    Columns for {schema}.{table}:
    <columns>\n\n{columns_str}\n\n</columns>
    """
    cursor.close()
    conn.close()
    return context

def get_all_tables_from_db(db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute("""
    SELECT table_schema, table_name FROM information_schema.tables
    WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
    """)
    tables = cursor.fetchall()
    cursor.close()
    conn.close()
    return tables


def get_all_table_contexts(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    table_contexts = [get_table_context(schema, table, db_credentials) for schema, table in tables]
    return '\n'.join(table_contexts)


def get_data_dictionary(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    data_dict = {}
    for schema, table in tables:
        conn = psycopg2.connect(**db_credentials)
        cursor = conn.cursor()
        cursor.execute(f"""
        SELECT column_name, data_type FROM information_schema.columns
        WHERE table_schema = '{schema}' AND table_name = '{table}'
        """)
        columns = cursor.fetchall()
        data_dict[f"{schema}.{table}"] = {col[0]: col[1] for col in columns}
        cursor.close()
        conn.close()
    return data_dict  


def get_final_system_prompt(db_credentials: dict):
    return GENERATE_SQL_PROMPT

if __name__ == "__main__":
    
    st.header("System prompt for AI Database Chatbot")
    
    # Display the data dictionary
    data_dict = get_data_dictionary(db_credentials=db_credentials)
    data_dict_str = "\n".join(
        [f"{table}:\n" + "\n".join(
            [f"    {column}: {dtype}" for column, dtype in columns.items()]) for table, columns in data_dict.items()])

    SYSTEM_PROMPT = get_final_system_prompt(db_credentials=db_credentials)
    st.markdown(SYSTEM_PROMPT)

```

## UI Components

```python
from typing import Dict, Any, List, Optional

"""UI components for menu operations with validation"""
import re
from typing import Dict, Any, List, Optional
import streamlit as st

from utils.database_functions import execute_menu_query

def validate_menu_update(data: Dict[str, Any]) -> List[str]:
    """Validate menu updates in real-time"""
    errors = []
    
    # Price validation
    if 'price' in data:
        try:
            price = float(data['price'])
            if price < 0:
                errors.append("Price must be non-negative")
            if price > 500:
                errors.append("Price cannot exceed $500.00")
            if len(str(price).split('.')[-1]) > 2:
                errors.append("Price cannot have more than 2 decimal places")
        except ValueError:
            errors.append("Invalid price format")
    
    # Time range validation
    if 'start_time' in data or 'end_time' in data:
        for key in ['start_time', 'end_time']:
            if key in data and data[key]:
                time_str = str(data[key])
2[0-3])([0-5]\d)$', time_str):
                    errors.append(f"{key.replace('_', ' ').title()} must be in 24-hour format (0000-2359)")
    
    # Option limits validation
    if 'min_selections' in data and 'max_selections' in data:
        min_val = data['min_selections']
        max_val = data['max_selections']
        if min_val > max_val:
            errors.append("Minimum selections cannot exceed maximum")
        if max_val > 10:
            errors.append("Maximum selections cannot exceed 10")
        if min_val < 0:
            errors.append("Minimum selections cannot be negative")
    
    return errors

def render_price_input(label: str, key: str, default: float = 0.0) -> float:
    """Render price input with validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        price = st.number_input(
            label,
            min_value=0.0,
            max_value=500.0,
            value=default,
            step=0.01,
            key=key,
            help="Enter price (0.00 - 500.00)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ℹ️
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Price Rules:
                • Must be non-negative
                • Maximum $500.00
                • Two decimal places
            </span>
        </div>
        """, unsafe_allow_html=True)
    return price

def render_time_input(label: str, key: str, default: str = "") -> str:
    """Render time input with 24-hour format validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        time = st.text_input(
            label,
            value=default,
            key=key,
            help="Enter time in 24-hour format (0000-2359)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ℹ️
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Time Format:
                • 24-hour format (0000-2359)
                • Examples: 0900, 1430, 2200
            </span>
        </div>
        """, unsafe_allow_html=True)
    
2[0-3])([0-5]\d)$', time):
        st.error('Time must be in 24-hour format (0000-2359)')
    return time

def render_option_limits(min_label: str, max_label: str, key_prefix: str) -> tuple[int, int]:
    """Render min/max selection limits with validation"""
    col1, col2, col3 = st.columns([2, 2, 1])
    
    with col1:
        min_val = st.number_input(
            min_label,
            min_value=0,
            max_value=10,
            value=0,
            step=1,
            key=f"{key_prefix}_min"
        )
    
    with col2:
        max_val = st.number_input(
            max_label,
            min_value=min_val,
            max_value=10,
            value=max(min_val, 1),
            step=1,
            key=f"{key_prefix}_max"
        )
    
    with col3:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ℹ️
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Selection Limits:
                • Min: 0-10 items
                • Max: Must be ≥ Min
                • Used for option groups
            </span>
        </div>
        """, unsafe_allow_html=True)
    
    return min_val, max_val

def render_location_hours_editor():
    """Render UI for location hours management"""
    st.subheader("Location Hours Management")
    
    location_id = st.number_input("Location ID", min_value=1)
    day_of_week = st.selectbox("Day of Week", 
        ["Monday", "Tuesday", "Wednesday", "Thursday", 
         "Friday", "Saturday", "Sunday"])
    
    col1, col2 = st.columns(2)
    with col1:
        open_time = st.text_input("Open Time (HH:MM:SS)")
    with col2:
        close_time = st.text_input("Close Time (HH:MM:SS)")
    
    if st.button("Update Hours"):
        if not all([location_id, day_of_week, open_time, close_time]):
            st.error("All fields are required")
        else:
            return {
                "operation": "update_location_hours",
                "params": {
                    "location_id": location_id,
                    "day_of_week": day_of_week,
                    "open_time": open_time,
                    "close_time": close_time
                }
            }
    return None

def render_marker_management():
    """Render UI for marker management"""
    st.subheader("Marker Management")
    
    location_id = st.number_input("Location ID", min_value=1, key="marker_loc_id")
    marker_name = st.text_input("Marker Name")
    disabled = st.checkbox("Disabled")
    
    if st.button("Add Marker"):
        if not all([location_id, marker_name]):
            st.error("Location ID and Marker Name are required")
        else:
            return {
                "operation": "add_marker",
                "params": {
                    "id": None,  # Will be auto-generated
                    "name": marker_name,
                    "disabled": disabled,
                    "location_id": location_id,
                    "deleted_at": None
                }
            }
    return None

def render_disable_interface(connection) -> Dict[str, Any]:
    """Render interface for disabling items/options by name"""
    st.subheader("Disable Item/Option")
    
    # Item/Option selection
    disable_type = st.radio(
        "Select type to disable",
        ["Menu Item", "Item Option", "Option Item"],
        help="Choose whether to disable a menu item, an option, or an option item"
    )
    
    # Name input
    item_name = st.text_input(
        f"Enter {disable_type.lower()} name",
        help="Enter the exact name to disable"
    )
    
    if not item_name:
        return None
        
    # Query current state
    if disable_type == "Menu Item":
        query = """
            SELECT i.id, i.name, i.disabled, c.name as category
            FROM items i
            JOIN categories c ON i.category_id = c.id
            WHERE i.name ILIKE %s AND i.deleted_at IS NULL
        """
    elif disable_type == "Item Option":
        query = """
            SELECT o.id, o.name, o.disabled, i.name as item
            FROM options o
            JOIN items i ON o.item_id = i.id
            WHERE o.name ILIKE %s AND o.deleted_at IS NULL
        """
    else:  # Option Item
        query = """
            SELECT oi.id, oi.name, oi.disabled, o.name as option, i.name as item
            FROM option_items oi
            JOIN options o ON oi.option_id = o.id
            JOIN items i ON o.item_id = i.id
            WHERE oi.name ILIKE %s AND oi.deleted_at IS NULL
        """
    
    results = execute_menu_query(query, (item_name,))
    
    if not results:
        st.error(f"No {disable_type.lower()} found with name: {item_name}")
        return None
        
    # Show current state
    st.write("Current state:")
    for item in results:
        status = "Disabled" if item["disabled"] else "Enabled"
        if disable_type == "Menu Item":
            st.info(f"Item: {item['name']} ({status}) in category: {item['category']}")
        elif disable_type == "Item Option":
            st.info(f"Option: {item['name']} ({status}) for item: {item['item']}")
        else:
            st.info(f"Option Item: {item['name']} ({status}) for option: {item['option']} on item: {item['item']}")
    
    # Confirmation
    if st.button(
        f"Disable {disable_type}",
        type="primary",
        help=f"Click to disable {item_name}"
    ):
        return {
            "type": disable_type,
            "name": item_name,
            "items": results
        }
    
    return None

```

