# Menu Updater Codebase Export

Generated on: 2025-02-21 11:30:48

# Project Overview

# Menu Updater

An AI-powered tool for Swoop customers to manage their restaurant menus through natural language queries and updates.

## System Overview

### Core Components

1. **Frontend (Streamlit)**
   - Interactive web interface with sidebar navigation
   - Common operations quick-access panel
   - Operation history display (last 5 operations)
   - Dark/light theme support
   - Real-time chat interface for natural language interactions

2. **Database (PostgreSQL)**
   - Hierarchical menu structure:
     ```
     Location
     ‚îî‚îÄ‚îÄ Menu
         ‚îî‚îÄ‚îÄ Category (with time ranges)
             ‚îî‚îÄ‚îÄ Item
                 ‚îî‚îÄ‚îÄ Option Group
                     ‚îî‚îÄ‚îÄ Option Items
     ```
   - All entities include:
     - Timestamps (created_at, updated_at, deleted_at)
     - Soft deletion via 'disabled' flag
     - Sequential ordering (seq_num) where applicable

3. **AI Integration (OpenAI)**
   - Natural language understanding for menu queries
   - Context-aware responses using operation history
   - Function calling for structured operations
   - Token management and conversation history

4. **Operation Management**
   - Location-specific operation storage
   - Common queries and updates
   - Operation history tracking (50 entries)
   - Template-based query generation

### Key Features

1. **Menu Structure**
   - Multi-location support
   - Time-based menu categories
   - Hierarchical item organization
   - Flexible option configurations
   - Price and availability management

2. **Operation Types**
   - View all active menu items
   - Search items by name/category
   - View time-based menu items
   - Update item prices
   - Enable/disable items
   - Modify descriptions
   - Manage option configurations

3. **Data Storage**
   - Location Settings (JSON)
     ```json
     {
       "common_operations": {
         "queries": [...],
         "updates": [...]
       },
       "operation_history": [
         {
           "timestamp": "2025-02-20T22:07:06Z",
           "operation_type": "query",
           "operation_name": "View Menu Items",
           "query_template": "SELECT ...",
           "result_summary": "Found 15 items"
         }
       ]
     }
     ```

4. **Validation Rules**
   - Non-negative prices
   - Valid time ranges (0-2359)
   - Required relationships maintained
   - Soft deletion preferred
   - Option constraints enforced

## Development Setup

1. **Clone the Repository:**
   ```bash
   git clone https://github.com/grow-assistant/menu-updater.git
   cd menu-updater
   ```

2. **Set Up Python Environment:**
   - Use Python 3.8 or higher
   - Create and activate a virtual environment (recommended)

3. **Set Up PostgreSQL:**
   - Install PostgreSQL
   - Create a new database for the project

4. **Configure Environment Variables:**
   Create a `.env` file with:
   ```
   DB_NAME=your_db_name
   DB_USER=your_db_user
   DB_PASSWORD=your_db_password
   DB_SERVER=localhost
   OPENAI_API_KEY=your_openai_key
   ```

5. **Install Dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

6. **Run the App:**
   ```bash
   streamlit run app.py
   ```
   The app will be available at http://localhost:8501

## Database Schema

### Key Tables

1. **locations**
   - id, name, description, timezone
   - settings (JSON for operations/history)
   - tax_rate, active/disabled flags

2. **menus**
   - id, name, description, location_id
   - disabled flag

3. **categories**
   - id, name, description, menu_id
   - start_time/end_time for availability
   - seq_num for ordering
   - disabled flag

4. **items**
   - id, name, description, price
   - category_id, seq_num
   - disabled flag

5. **options**
   - id, name, description
   - min/max selections
   - item_id, disabled flag

6. **option_items**
   - id, name, description, price
   - option_id, disabled flag

---



# Source Code

## Main Application

```python
import streamlit as st
from utils.config import db_credentials, MAX_TOKENS_ALLOWED, MAX_MESSAGES_TO_OPENAI, TOKEN_BUFFER
from utils.system_prompts import get_final_system_prompt
from utils.chat_functions import run_chat_sequence, clear_chat_history, count_tokens, prepare_sidebar_data
from utils.database_functions import database_schema_dict
from utils.function_calling_spec import functions
from utils.helper_functions import save_conversation
from utils.ui_components import (
    render_price_input,
    render_time_input,
    render_option_limits,
    validate_menu_update
)
from assets.dark_theme import dark
from assets.light_theme import light
from assets.made_by_sdw import made_by_sdw





if __name__ == "__main__":

    ########### A. SIDEBAR ###########

    # Prepare data for the sidebar dropdowns
    sidebar_data = prepare_sidebar_data(database_schema_dict)
    st.sidebar.markdown("<div class='made_by'>Made by SDWüîã</div>", unsafe_allow_html=True)

    ### MENU OPERATIONS ###
    st.sidebar.title("üçΩÔ∏è Menu Operations")
    
    # Add custom CSS for tooltips
    st.markdown("""
        <style>
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            background-color: #555;
            color: #fff;
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        </style>
    """, unsafe_allow_html=True)
    
    # Add menu operation buttons
    operation = None
    if st.sidebar.button("üîç View Menu Items"):
        operation = "query"
        st.session_state["operation"] = "query"
    
    # Price update section
    if st.sidebar.button("üí∞ Update Prices"):
        operation = "update"
        st.session_state["operation"] = "update"
        # Show price input when update is selected
        if "operation" in st.session_state and st.session_state["operation"] == "update":
            st.sidebar.subheader("Update Price")
            item_id = st.sidebar.number_input("Item ID", min_value=1, step=1)
            new_price = render_price_input("New Price", f"price_{item_id}")
            
            # Validate price input
            validation_data = {'price': new_price}
            if errors := validate_menu_update(validation_data):
                st.sidebar.error("\n".join(errors))
    
    # Time range section
    if st.sidebar.button("‚è∞ Update Time Range"):
        operation = "time"
        st.session_state["operation"] = "time"
        # Show time inputs when time range update is selected
        if "operation" in st.session_state and st.session_state["operation"] == "time":
            st.sidebar.subheader("Update Time Range")
            category_id = st.sidebar.number_input("Category ID", min_value=1, step=1)
            start_time = render_time_input("Start Time", f"start_{category_id}")
            end_time = render_time_input("End Time", f"end_{category_id}")
            
            # Validate time inputs
            validation_data = {'start_time': start_time, 'end_time': end_time}
            if errors := validate_menu_update(validation_data):
                st.sidebar.error("\n".join(errors))
    
    # Option limits section
    if st.sidebar.button("üî¢ Update Option Limits"):
        operation = "limits"
        st.session_state["operation"] = "limits"
        # Show option limit inputs when selected
        if "operation" in st.session_state and st.session_state["operation"] == "limits":
            st.sidebar.subheader("Update Option Limits")
            option_id = st.sidebar.number_input("Option ID", min_value=1, step=1)
            min_val, max_val = render_option_limits(
                "Minimum Selections",
                "Maximum Selections",
                f"option_{option_id}"
            )
            
            # Validate option limits
            validation_data = {'min_selections': min_val, 'max_selections': max_val}
            if errors := validate_menu_update(validation_data):
                st.sidebar.error("\n".join(errors))
    
    # Enable/disable section
    if st.sidebar.button("‚ö° Enable/Disable Items"):
        operation = "toggle"
        st.session_state["operation"] = "toggle"
    
    # Display current operation
    if "operation" in st.session_state:
        st.sidebar.info(f"Current Operation: {st.session_state['operation'].title()}")

    ### POSTGRES DB OBJECTS VIEWER ###
    st.markdown(made_by_sdw, unsafe_allow_html=True)
    st.sidebar.title("üìä Database Structure")


    # Dropdown for schema selection
    selected_schema = st.sidebar.selectbox("üìÇ Select a schema", list(sidebar_data.keys()))


    # Dropdown for table selection based on chosen Schema
    selected_table = st.sidebar.selectbox("üìú Select a table", list(sidebar_data[selected_schema].keys()))


    # Display columns of the chosen table with interactivity using checkboxes
    st.sidebar.subheader(f"üîó Columns in {selected_table}")
    for column in sidebar_data[selected_schema][selected_table]:
        is_checked = st.sidebar.checkbox(f"üìå {column}") 





    ### SAVE CONVERSATION BUTTON ###

    # Add a button to SAVE the chat/conversation
    if st.sidebar.button("Save Conversationüíæ"):
        saved_file_path = save_conversation(st.session_state["full_chat_history"])
        st.sidebar.success(f"Conversation saved to: {saved_file_path}")
        st.sidebar.markdown(f"Conversation saved! [Open File]({saved_file_path})")

    
    
    

    ### CLEAR CONVERSATION BUTTON ###

    # Add a button to CLEAR the chat/conversation
    if st.sidebar.button("Clear ConversationüóëÔ∏è"):
        save_conversation(st.session_state["full_chat_history"]) 
        clear_chat_history()





    ### TOGGLE THEME BUTTON ###

    # Retrieve the current theme from session state
    current_theme = st.session_state.get("theme", "light")
    st.markdown(f"<body class='{current_theme}'></body>", unsafe_allow_html=True)


    # Initialize the theme in session state
    if "theme" not in st.session_state:
        st.session_state.theme = "light"


    # Add a button to toggle the UI colour theme
    if st.sidebar.button("Toggle Themeüö®"):
        st.session_state.theme = "dark" if st.session_state.theme == "light" else "light"
        st.rerun()



    # Apply the theme based on session state
    theme_style = dark if st.session_state.theme == "dark" else light
    st.markdown(theme_style, unsafe_allow_html=True)











    ########### B. CHAT INTERFACE ###########


    
    ### TITLE ###

    # Add title to the Streamlit chatbot app
    st.title("ü§ñ AI Database Chatbot ü§ì")



    ### SESSION STATE ###

    # Initialize the full chat messages history for UI
    if "full_chat_history" not in st.session_state:
        st.session_state["full_chat_history"] = [{"role": "system", "content": get_final_system_prompt(db_credentials=db_credentials)}]



    # Initialize the API chat messages history for OpenAI requests
    if "api_chat_history" not in st.session_state:
        st.session_state["api_chat_history"] = [{"role": "system", "content": get_final_system_prompt(db_credentials=db_credentials)}]



    ### CHAT FACILITATION ###

    # Start the chat
    if (prompt := st.chat_input("What do you want to know?")) is not None:
        st.session_state.full_chat_history.append({"role": "user", "content": prompt})

        # Limit the number of messages sent to OpenAI by token count
        total_tokens = sum(count_tokens(message["content"]) for message in st.session_state["api_chat_history"])
        while total_tokens + count_tokens(prompt) + TOKEN_BUFFER > MAX_TOKENS_ALLOWED:
            removed_message = st.session_state["api_chat_history"].pop(0)
            total_tokens -= count_tokens(removed_message["content"])

        st.session_state.api_chat_history.append({"role": "user", "content": prompt})



    # Display previous chat messages from full_chat_history (ingore system prompt message)
    for message in st.session_state["full_chat_history"][1:]:
        if message["role"] == "user":
            st.chat_message("user", avatar='üßë‚Äçüíª').write(message["content"])
        elif message["role"] == "assistant":
            st.chat_message("assistant", avatar='ü§ñ').write(message["content"])

    if st.session_state["api_chat_history"][-1]["role"] != "assistant":
        with st.spinner("‚åõConnecting to AI model..."):
            # Send only the most recent messages to OpenAI from api_chat_history
            recent_messages = st.session_state["api_chat_history"][-MAX_MESSAGES_TO_OPENAI:]
            
            # Add operation context if set
            if "operation" in st.session_state:
                operation_context = {
                    "query": "I want to view menu items. ",
                    "update": "I want to update menu prices. ",
                    "toggle": "I want to enable or disable menu items. "
                }.get(st.session_state["operation"], "")
                if operation_context:
                    recent_messages[-1]["content"] = operation_context + recent_messages[-1]["content"]
            
            new_message = run_chat_sequence(recent_messages, functions)  # Get the latest message

            # Add this latest message to both api_chat_history and full_chat_history
            st.session_state["api_chat_history"].append(new_message)
            st.session_state["full_chat_history"].append(new_message)

            # Display the latest message from the assistant
            st.chat_message("assistant", avatar='ü§ñ').write(new_message["content"])

        max_tokens = MAX_TOKENS_ALLOWED
        current_tokens = sum(count_tokens(message["content"]) for message in st.session_state["full_chat_history"])
        progress = min(1.0, max(0.0, current_tokens / max_tokens))
        st.progress(progress)
        st.write(f"Tokens Used: {current_tokens}/{max_tokens}")
        if current_tokens > max_tokens:
            st.warning("Note: Due to character limits, some older messages might not be considered in ongoing conversations with the AI.")

```

## Analytics

```python
"""Analytics functions for menu suggestions"""
from typing import List, Dict, Any
from datetime import datetime, timedelta

def get_item_suggestions(connection, item_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on order history"""
    try:
        with connection.cursor() as cursor:
            # Find items frequently ordered together
            cursor.execute("""
                WITH item_orders AS (
                    SELECT DISTINCT order_id 
                    FROM order_items 
                    WHERE item_id = %s
                ),
                related_items AS (
                    SELECT 
                        i.id,
                        i.name,
                        i.price,
                        c.name as category,
                        COUNT(*) as co_occurrence,
                        ROUND(COUNT(*) * 100.0 / (
                            SELECT COUNT(DISTINCT order_id) 
                            FROM order_items 
                            WHERE item_id = %s
                        ), 2) as order_percentage
                    FROM order_items oi
                    JOIN item_orders io ON oi.order_id = io.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE oi.item_id != %s
                      AND i.disabled = false
                      AND c.disabled = false
                    GROUP BY i.id, i.name, i.price, c.name
                    HAVING COUNT(*) >= 5
                    ORDER BY co_occurrence DESC, order_percentage DESC
                    LIMIT 5
                )
                SELECT 
                    id,
                    name,
                    price,
                    category,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders
                FROM related_items;
            """, (item_id, item_id, item_id))
            
            columns = ['id', 'name', 'price', 'category', 'times_ordered_together', 'percentage_of_orders']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def get_category_suggestions(connection, category_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on category relationships"""
    try:
        with connection.cursor() as cursor:
            # Find categories frequently ordered together
            cursor.execute("""
                WITH category_orders AS (
                    SELECT DISTINCT o.id as order_id
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    WHERE i.category_id = %s
                ),
                related_categories AS (
                    SELECT 
                        c.id,
                        c.name,
                        COUNT(DISTINCT co.order_id) as co_occurrence,
                        ROUND(COUNT(DISTINCT co.order_id) * 100.0 / (
                            SELECT COUNT(*) FROM category_orders
                        ), 2) as order_percentage,
                        ARRAY_AGG(DISTINCT i.name) as popular_items
                    FROM category_orders co
                    JOIN order_items oi ON co.order_id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE c.id != %s
                      AND c.disabled = false
                    GROUP BY c.id, c.name
                    HAVING COUNT(DISTINCT co.order_id) >= 3
                    ORDER BY co_occurrence DESC
                    LIMIT 3
                )
                SELECT 
                    id,
                    name,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders,
                    popular_items
                FROM related_categories;
            """, (category_id, category_id))
            
            columns = ['id', 'name', 'times_ordered_together', 'percentage_of_orders', 'popular_items']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def format_suggestion_message(item_suggestions: List[Dict[str, Any]], 
                            category_suggestions: List[Dict[str, Any]]) -> str:
    """Format suggestions into a readable message"""
    message_parts = []
    
    if item_suggestions:
        items = "\n".join(
            f"‚Ä¢ {item['name']} (${item['price']:.2f}) - "
            f"ordered together {item['times_ordered_together']} times "
            f"({item['percentage_of_orders']}% of orders)"
            for item in item_suggestions
        )
        message_parts.append(f"Suggested items:\n{items}")
    
    if category_suggestions:
        categories = "\n".join(
            f"‚Ä¢ {cat['name']} - appears in {cat['percentage_of_orders']}% "
            f"of orders with popular items: {', '.join(cat['popular_items'][:3])}"
            for cat in category_suggestions
        )
        message_parts.append(f"Suggested categories:\n{categories}")
    
    return "\n\n".join(message_parts) if message_parts else "No suggestions available"

```

## API Functions

```python
import json
import requests
from utils.config import OPENAI_API_KEY, AI_MODEL
from utils.database_functions import ask_postgres_database, postgres_connection
from tenacity import retry, wait_random_exponential, stop_after_attempt



@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))
def send_api_request_to_openai_api(messages, functions=None, function_call=None, model=AI_MODEL, openai_api_key=OPENAI_API_KEY):
    """ Send the API request to the OpenAI API via Chat Completions endpoint """
    try:
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {openai_api_key}"}
        json_data = {"model": model, "messages": messages}
        if functions: 
            json_data.update({"functions": functions})
        if function_call: 
            json_data.update({"function_call": function_call})
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, json=json_data)
        response.raise_for_status()

        return response
    
    except requests.RequestException as e:
        raise ConnectionError(f"Failed to connect to OpenAI API due to: {e}")


def execute_function_call(message):
    """ Run the function call provided by OpenAI's API response """
    if message["function_call"]["name"] == "ask_postgres_database":
        query = json.loads(message["function_call"]["arguments"])["query"]
        print(f"SQL query: {query} \n")
        results = ask_postgres_database(postgres_connection, query)
        print(f"Results A: {results} \n")
    else:
        results = f"Error: function {message['function_call']['name']} does not exist"
    return results


```

## Chat Functions

```python
import tiktoken
import streamlit as st
from utils.config import AI_MODEL
from utils.api_functions import send_api_request_to_openai_api, execute_function_call
from utils.menu_analytics import (
    get_recent_operations,
    get_popular_items,
    analyze_time_patterns,
    get_category_relationships
)







def run_chat_sequence(messages, functions):
    if "live_chat_history" not in st.session_state:
        st.session_state["live_chat_history"] = [{"role": "assistant", "content": "Hello! I'm Andy, how can I assist you?"}]
        # st.session_state["live_chat_history"] = []

    internal_chat_history = st.session_state["live_chat_history"].copy()
    
    # Make a copy of messages to avoid modifying the original
    messages = messages.copy()

    # Add enhanced context if location_id available
    if "location_id" in st.session_state and "postgres_connection" in st.session_state:
        location_id = st.session_state["location_id"]
        connection = st.session_state["postgres_connection"]
        
        # Get context data
        context = {
            'recent_operations': get_recent_operations(connection, location_id, limit=10),
            'popular_items': get_popular_items(connection, location_id),
            'time_patterns': analyze_time_patterns(connection, location_id),
            'category_relationships': get_category_relationships(connection, location_id)
        }
        
        # Format context sections
        context_sections = []
        
        # Format operations
        if context['recent_operations']:
            ops = "\n".join(f"- {op['operation_type']}: {op['operation_name']} ({op['result_summary']})"
                          for op in context['recent_operations'])
            context_sections.append(f"Recent operations:\n{ops}")
        
        # Format popular items
        if context['popular_items']:
            items = "\n".join(f"- {item['name']} (${item['price']:.2f}, {item['orders']} orders)"
                           for item in context['popular_items'])
            context_sections.append(f"Popular items:\n{items}")
        
        # Format time patterns
        if 'time_based_categories' in context['time_patterns']:
            patterns = "\n".join(f"- {p['category']} ({p['time_range']}: {p['orders']} orders)"
                              for p in context['time_patterns']['time_based_categories'])
            context_sections.append(f"Time-based patterns:\n{patterns}")
        
        # Format category relationships
        if context['category_relationships']:
            relationships = []
            for cat1, related in context['category_relationships'].items():
                related_str = ", ".join(f"{r['category']} ({r['frequency']} orders)" 
                                      for r in related[:3])
                relationships.append(f"- {cat1} often ordered with: {related_str}")
            if relationships:
                context_sections.append("Category relationships:\n" + "\n".join(relationships))
        
        # Add context to message
        if context_sections:
            context_str = "Context:\n" + "\n\n".join(context_sections)
            messages[-1]["content"] = context_str + "\n\nUser query: " + messages[-1]["content"]

    # Add query template context if available
    if "query_template" in st.session_state:
        messages[-1]["content"] += f"\nUse this query template: {st.session_state['query_template']}"
        del st.session_state["query_template"]

    chat_response = send_api_request_to_openai_api(messages, functions)
    assistant_message = chat_response.json()["choices"][0]["message"]
    
    if assistant_message["role"] == "assistant":
        internal_chat_history.append(assistant_message)

    if assistant_message.get("function_call"):
        results = execute_function_call(assistant_message)
        internal_chat_history.append({"role": "function", "name": assistant_message["function_call"]["name"], "content": results})
        internal_chat_history.append({"role": "user", "content": "You are a data analyst - provide personalized/customized explanations on what the results provided means and link them to the the context of the user query using clear, concise words in a user-friendly way. Or answer the question provided by the user in a helpful manner - either way, make sure your responses are human-like and relate to the initial user input. Your answers must not exceed 200 characters"})
        chat_response = send_api_request_to_openai_api(internal_chat_history, functions)
        assistant_message = chat_response.json()["choices"][0]["message"]
        if assistant_message["role"] == "assistant":
            st.session_state["live_chat_history"].append(assistant_message)

    return st.session_state["live_chat_history"][-1]


def clear_chat_history():
    """ Clear the chat history stored in the Streamlit session state """
    del st.session_state["live_chat_history"]
    del st.session_state["full_chat_history"]
    del st.session_state["api_chat_history"]


def count_tokens(text):
    """ Count the total tokens used in a text string """
    if not isinstance(text, str):  
        return 0 
    encoding = tiktoken.encoding_for_model(AI_MODEL)
    total_tokens_in_text_string = len(encoding.encode(text))
    
    return total_tokens_in_text_string


def prepare_sidebar_data(database_schema_dict):
    """ Add a sidebar for visualizing the database schema objects  """
    sidebar_data = {}
    for table in database_schema_dict:
        schema_name = table["schema_name"]
        table_name = table["table_name"]
        columns = table["column_names"]

        if schema_name not in sidebar_data:
            sidebar_data[schema_name] = {}

        sidebar_data[schema_name][table_name] = columns
    return sidebar_data


```

## Configuration

```python
import os 
from dotenv import load_dotenv


load_dotenv()


# Set up Postgres database credentials
db_credentials = {
    "dbname": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"), 
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_SERVER"),
    "port": os.getenv("DB_PORT")
}

# Set up OpenAI variables 
OPENAI_API_KEY  =   os.getenv("OPENAI_API_KEY")
AI_MODEL        =   'gpt-4o-mini'
# AI_MODEL        =   'gpt-4'



# Max number of tokens permitted within a conversation exchange via OpenAI API
MAX_TOKENS_ALLOWED      =   4000


# Max number of messages to exchange with OpenAI API
MAX_MESSAGES_TO_OPENAI  =   10



# An arbitrary number to provide a buffer to avoid reaching exact token limits
TOKEN_BUFFER            =   200  

```

## Database Functions

```python
import psycopg2
import re
import json
import streamlit as st
from utils.config import db_credentials
from utils.menu_operations import add_operation_to_history

# Establish connection with PostgreSQL
try:
    postgres_connection = psycopg2.connect(**db_credentials)
    postgres_connection.set_session(autocommit=True)
except Exception as e:
    raise ConnectionError(f"Unable to connect to the database due to: {e}")



# Create a database cursor to execute PostgreSQL commands
cursor = postgres_connection.cursor()


# Validate the PostgreSQL connection status
if postgres_connection.closed == 0:
    print(f"Connected successfully to {db_credentials['dbname']} database\nConnection Details: {postgres_connection.dsn}")
else:
    raise ConnectionError("Unable to connect to the database")




def get_schema_names(database_connection):
    """ Returns a list of schema names """
    cursor = database_connection.cursor()
    cursor.execute("SELECT schema_name FROM information_schema.schemata;")
    schema_names = [row[0] for row in cursor.fetchall()]
    cursor.close()
    return schema_names


def get_table_names(connection, schema_name):
    """ Returns a list of table names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT table_name FROM information_schema.tables WHERE table_schema = '{schema_name}';")
    table_names = [table[0] for table in cursor.fetchall()]
    cursor.close()
    return table_names


def get_column_names(connection, table_name, schema_name):
    """ Returns a list of column names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}' AND table_schema = '{schema_name}';")
    column_names = [col[0] for col in cursor.fetchall()]
    cursor.close()
    return column_names


def get_database_info(connection, schema_names):
    """ Fetches information about the schemas, tables and columns in the database """
    table_dicts = []
    for schema in schema_names:
        for table_name in get_table_names(connection, schema):
            column_names = get_column_names(connection, table_name, schema)
            table_dicts.append({"table_name": table_name, "column_names": column_names, "schema_name": schema})
    return table_dicts


# To print details to the console:
# schemas = get_schema_names(postgres_connection)
# here you need to set schema name from postgres by default the schema is public in postgres database. you can see in pgadmin
schemas = ['public']
database_schema_dict = get_database_info(postgres_connection, schemas)
database_schema_string = "\n".join(
    [
        f"Schema: {table['schema_name']}\nTable: {table['table_name']}\nColumns: {', '.join(table['column_names'])}"
        for table in database_schema_dict
    ]
)



def ask_postgres_database(connection, query):
    """ Execute the SQL query provided by OpenAI and return the results """
    try:
        with connection.cursor() as cursor:
            cursor.execute(query)
            results = str(cursor.fetchall())
        return results
    except Exception as e:
        return f"Query failed with error: {e}"

def get_location_settings(connection, location_id):
    """Get location settings including common operations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT settings FROM locations WHERE id = %s", (location_id,))
            result = cursor.fetchone()
        return json.loads(result[0]) if result and result[0] else {}
    except Exception as e:
        return f"Failed to get location settings: {e}"

def update_location_settings(connection, location_id, settings):
    """Update location settings"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("UPDATE locations SET settings = %s WHERE id = %s", 
                         (json.dumps(settings), location_id))
        return "Settings updated successfully"
    except Exception as e:
        return f"Failed to update settings: {e}"

def extract_item_id(query):
    """Extract item ID from update query"""
    match = re.search(r'WHERE\s+(?:items\.)?id\s*=\s*(\d+)', query, re.IGNORECASE)
    if not match:
        raise ValueError("Update queries must include item ID in WHERE clause")
    return int(match.group(1))

def validate_time_range(time_str):
    """Validate time range format (0000-2359)"""
2[0-3])([0-5]\d)$', time_str):
        raise ValueError("Time must be in 24-hour format (0000-2359)")
    return True

def execute_menu_update(connection, query, operation_name=None):
    """Execute menu update with row-level locking and validation"""
    try:
        with connection:  # Auto-commits or rolls back
            with connection.cursor() as cursor:
                # Set transaction isolation level
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Extract and validate item ID for item updates
                item_id = None
                if "UPDATE items" in query.lower():
                    item_id = extract_item_id(query)
                    # Acquire row-level lock
                    cursor.execute("SELECT * FROM items WHERE id = %s FOR UPDATE", (item_id,))
                    
                    # Validate query plan
                    cursor.execute("EXPLAIN " + query)
                    plan = cursor.fetchall()
                    if not any('Index Scan' in str(row) for row in plan):
                        raise ValueError("Query must use index for updates")
                
                # Validate price updates
                if "UPDATE items SET price" in query.lower():
                    cursor.execute("SELECT COUNT(*) FROM (" + query.replace(";", "") + ") as q WHERE price < 0")
                    if cursor.fetchone()[0] > 0:
                        raise ValueError("Price updates must be non-negative")
                
                # Validate time ranges
                if "UPDATE categories" in query.lower() and ("start_time" in query or "end_time" in query):
end)_time\s*=\s*(\d{4})', query, re.IGNORECASE)
                    for time_str in time_matches:
                        validate_time_range(time_str)
                
                # Execute update
                cursor.execute(query)
                affected = cursor.rowcount
                
                # Record operation in history if name provided
                if operation_name and "location_id" in st.session_state:
                    settings = get_location_settings(connection, st.session_state["location_id"])
                    settings = add_operation_to_history(settings, {
                        "operation_type": "update",
                        "operation_name": operation_name,
                        "query_template": query,
                        "result_summary": f"Updated {affected} rows"
                    })
                    update_location_settings(connection, st.session_state["location_id"], settings)
                
                return f"Update successful. {affected} rows affected."
    except Exception as e:
        # Transaction will automatically rollback
        return f"Update failed: {e}"

```

## Function Calling Spec

```python
from utils.database_functions import database_schema_string

# Specify function descriptions for OpenAI function calling 
functions = [
    {
        "name": "query_menu_items",
        "description": "Query menu items and their details",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to fetch menu items. Available tables and relationships:
                        - locations (id, name, description, disabled)
                        - menus (id, name, description, location_id, disabled)
                        - categories (id, name, description, menu_id, disabled, start_time, end_time)
                        - items (id, name, description, price, category_id, disabled)
                        - options (id, name, description, min, max, item_id, disabled)
                        - option_items (id, name, description, price, option_id, disabled)
                        
                        Join through proper hierarchy: locations -> menus -> categories -> items.
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "update_menu_item",
        "description": "Update menu item properties like price or description",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to update menu items. Validation rules:
                        - Prices must be non-negative
                        - Items should be disabled rather than deleted
                        - Time-based menu categories must have valid time ranges (0-2359)
                        
                        Example: UPDATE items SET price = 12.99 WHERE id = 123 AND price >= 0
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "toggle_menu_item",
        "description": "Enable or disable menu items",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to update item.disabled flag. Rules:
                        - Use UPDATE items SET disabled = true/false
                        - Must include WHERE clause for safety
                        
                        Example: UPDATE items SET disabled = true WHERE id = 123
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    }
]

```

## Help Functions

```python
Error reading file utils/help_functions.py: [Errno 2] No such file or directory: 'utils/help_functions.py'
```

## Menu Analytics

```python
"""Menu analytics functions for AI context"""
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any
from utils.database_functions import get_location_settings

def get_recent_operations(connection, location_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    """Get recent menu operations for a location"""
    try:
        settings = get_location_settings(connection, location_id)
        if isinstance(settings, str):  # Error message returned
            return []
        history = settings.get('operation_history', [])
        return history[:limit]
    except Exception as e:
        return []

def get_popular_items(connection, location_id: int) -> List[Dict[str, Any]]:
    """Get popular menu items based on analytics"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT i.id, i.name, i.price, 
                       a.views, a.orders, a.revenue,
                       a.last_ordered
                FROM items i
                JOIN menu_item_analytics a ON i.id = a.item_id
                JOIN categories c ON i.category_id = c.id
                JOIN menus m ON c.menu_id = m.id
                WHERE m.location_id = %s
                  AND i.disabled = false
                ORDER BY a.orders DESC, a.revenue DESC
                LIMIT 10
            """, (location_id,))
            columns = ['id', 'name', 'price', 'views', 'orders', 'revenue', 'last_ordered']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def analyze_time_patterns(connection, location_id: int) -> Dict[str, Any]:
    """Analyze time-based ordering patterns"""
    try:
        with connection.cursor() as cursor:
            # Get items with time restrictions
            cursor.execute("""
                SELECT c.name as category,
                       c.start_time,
                       c.end_time,
                       COUNT(DISTINCT i.id) as item_count,
                       SUM(a.orders) as total_orders
                FROM categories c
                JOIN items i ON i.category_id = c.id
                JOIN menu_item_analytics a ON i.id = a.item_id
                WHERE c.menu_id IN (
                    SELECT id FROM menus WHERE location_id = %s
                )
                AND c.start_time IS NOT NULL
                GROUP BY c.name, c.start_time, c.end_time
                ORDER BY c.start_time
            """, (location_id,))
            
            patterns = []
            for row in cursor.fetchall():
                patterns.append({
                    'category': row[0],
                    'time_range': f"{row[1]:04d}-{row[2]:04d}",
                    'items': row[3],
                    'orders': row[4]
                })
            
            return {
                'time_based_categories': patterns,
                'analysis_date': datetime.now().isoformat()
            }
    except Exception as e:
        return {'error': str(e)}

def get_category_relationships(connection, location_id: int) -> Dict[str, List[str]]:
    """Get commonly ordered category combinations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                WITH order_categories AS (
                    SELECT DISTINCT o.id as order_id,
                           c.name as category_name
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    JOIN menus m ON c.menu_id = m.id
                    WHERE m.location_id = %s
                ),
                category_pairs AS (
                    SELECT a.category_name as cat1,
                           b.category_name as cat2,
                           COUNT(*) as frequency
                    FROM order_categories a
                    JOIN order_categories b ON a.order_id = b.order_id
                    WHERE a.category_name < b.category_name
                    GROUP BY a.category_name, b.category_name
                    HAVING COUNT(*) >= 5
                    ORDER BY COUNT(*) DESC
                )
                SELECT cat1, cat2, frequency
                FROM category_pairs
                LIMIT 10
            """, (location_id,))
            
            relationships = {}
            for row in cursor.fetchall():
                if row[0] not in relationships:
                    relationships[row[0]] = []
                relationships[row[0]].append({
                    'category': row[1],
                    'frequency': row[2]
                })
            
            return relationships
    except Exception as e:
        return {}

```

## Menu Operations

```python
from datetime import datetime
import psycopg2
from typing import Dict, List, Optional, Tuple, Union

def add_operation_to_history(
    operation_type: str,
    details: Dict,
    status: str,
    connection
) -> None:
    """
    Add an operation to the history table
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            INSERT INTO operation_history 
            (operation_type, operation_details, status, timestamp)
            VALUES (%s, %s, %s, %s)
            """,
            (operation_type, str(details), status, datetime.now())
        )
        connection.commit()
    except Exception as e:
        print(f"Error adding operation to history: {e}")
    finally:
        cursor.close()

def update_menu_item_price(
    item_id: int,
    new_price: float,
    connection
) -> Tuple[bool, str]:
    """
    Update the price of a menu item
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            "UPDATE menu_items SET price = %s WHERE item_id = %s",
            (new_price, item_id)
        )
        connection.commit()
        return True, "Price updated successfully"
    except Exception as e:
        return False, f"Error updating price: {e}"
    finally:
        cursor.close()

def update_category_time_range(
    category_id: int,
    start_time: str,
    end_time: str,
    connection
) -> Tuple[bool, str]:
    """
    Update the time range for a category
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE categories 
            SET available_start_time = %s, available_end_time = %s 
            WHERE category_id = %s
            """,
            (start_time, end_time, category_id)
        )
        connection.commit()
        return True, "Time range updated successfully"
    except Exception as e:
        return False, f"Error updating time range: {e}"
    finally:
        cursor.close()

def update_option_limits(
    option_id: int,
    min_selections: int,
    max_selections: int,
    connection
) -> Tuple[bool, str]:
    """
    Update the minimum and maximum selections for an option group
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE option_groups 
            SET min_selections = %s, max_selections = %s 
            WHERE option_group_id = %s
            """,
            (min_selections, max_selections, option_id)
        )
        connection.commit()
        return True, "Option limits updated successfully"
    except Exception as e:
        return False, f"Error updating option limits: {e}"
    finally:
        cursor.close()

def toggle_item_availability(
    item_id: int,
    is_available: bool,
    connection
) -> Tuple[bool, str]:
    """
    Toggle the availability status of a menu item
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            "UPDATE menu_items SET is_available = %s WHERE item_id = %s",
            (is_available, item_id)
        )
        connection.commit()
        return True, f"Item {'enabled' if is_available else 'disabled'} successfully"
    except Exception as e:
        return False, f"Error toggling item availability: {e}"
    finally:
        cursor.close() 
```

## System Prompts

```python
import psycopg2
import streamlit as st
from utils.config import db_credentials


GENERATE_SQL_PROMPT = """
You are Andy, a menu management specialist. Your mission is to help customers query and update their menu items through natural language requests. You understand restaurant operations and help customers maintain their menus efficiently.

Please follow these guidelines for menu operations:
<rules>
1. For menu queries, always join through the proper hierarchy: locations -> menus -> categories -> items
2. When updating prices, ensure values are non-negative and validate before committing
3. For item updates, use the disabled flag instead of deletion to maintain history
4. Maintain option configurations according to min/max constraints (options.min and options.max)
5. Respect time-based menu category constraints (categories.start_time and categories.end_time)
6. Use wildcards like "%keyword%" with LIKE for flexible text matching
7. Present SQL queries in a neat markdown format, like ```sql code```
8. Aim to offer just a single SQL script in one response
9. Guard against SQL injection by cleaning user inputs
10. If a query doesn't yield results, suggest similar menu items or categories
</rules>

Begin with a brief introduction as Andy and offer an overview of available metrics. However, avoid naming every table or schema. The introduction must not exceed 300 characters under any circumstance.

For each SQL output, include a brief rationale, display the outcome, and provide an explanation in context to the user's original request. Always format SQL as {{database}}.{{schema}}.{{table}}.

Before presenting, confirm the validity of SQL scripts and dataframes. Assess if a user's query truly needs a database response. If not, guide them as necessary.

"""


@st.cache_data(show_spinner=False)
def get_table_context(schema: str, table: str, db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute(f"""
    SELECT column_name, data_type FROM information_schema.columns
    WHERE table_schema = '{schema}' AND table_name = '{table}'
    """)
    columns = cursor.fetchall()

    columns_str = "\n".join([f"- **{col[0]}**: {col[1]}" for col in columns])
    context = f"""
    Table: <tableName> {schema}.{table} </tableName>
    Columns for {schema}.{table}:
    <columns>\n\n{columns_str}\n\n</columns>
    """
    cursor.close()
    conn.close()
    return context

def get_all_tables_from_db(db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute("""
    SELECT table_schema, table_name FROM information_schema.tables
    WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
    """)
    tables = cursor.fetchall()
    cursor.close()
    conn.close()
    return tables


def get_all_table_contexts(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    table_contexts = [get_table_context(schema, table, db_credentials) for schema, table in tables]
    return '\n'.join(table_contexts)


def get_data_dictionary(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    data_dict = {}
    for schema, table in tables:
        conn = psycopg2.connect(**db_credentials)
        cursor = conn.cursor()
        cursor.execute(f"""
        SELECT column_name, data_type FROM information_schema.columns
        WHERE table_schema = '{schema}' AND table_name = '{table}'
        """)
        columns = cursor.fetchall()
        data_dict[f"{schema}.{table}"] = {col[0]: col[1] for col in columns}
        cursor.close()
        conn.close()
    return data_dict  


def get_final_system_prompt(db_credentials: dict):
    return GENERATE_SQL_PROMPT

if __name__ == "__main__":
    
    st.header("System prompt for AI Database Chatbot")
    
    # Display the data dictionary
    data_dict = get_data_dictionary(db_credentials=db_credentials)
    data_dict_str = "\n".join(
        [f"{table}:\n" + "\n".join(
            [f"    {column}: {dtype}" for column, dtype in columns.items()]) for table, columns in data_dict.items()])

    SYSTEM_PROMPT = get_final_system_prompt(db_credentials=db_credentials)
    st.markdown(SYSTEM_PROMPT)

```

## UI Components

```python
"""UI components for menu operations with validation"""
import re
from typing import Dict, Any, List, Optional
import streamlit as st

def validate_menu_update(data: Dict[str, Any]) -> List[str]:
    """Validate menu updates in real-time"""
    errors = []
    
    # Price validation
    if 'price' in data:
        try:
            price = float(data['price'])
            if price < 0:
                errors.append("Price must be non-negative")
            if price > 500:
                errors.append("Price cannot exceed $500.00")
            if len(str(price).split('.')[-1]) > 2:
                errors.append("Price cannot have more than 2 decimal places")
        except ValueError:
            errors.append("Invalid price format")
    
    # Time range validation
    if 'start_time' in data or 'end_time' in data:
        for key in ['start_time', 'end_time']:
            if key in data and data[key]:
                time_str = str(data[key])
2[0-3])([0-5]\d)$', time_str):
                    errors.append(f"{key.replace('_', ' ').title()} must be in 24-hour format (0000-2359)")
    
    # Option limits validation
    if 'min_selections' in data and 'max_selections' in data:
        min_val = data['min_selections']
        max_val = data['max_selections']
        if min_val > max_val:
            errors.append("Minimum selections cannot exceed maximum")
        if max_val > 10:
            errors.append("Maximum selections cannot exceed 10")
        if min_val < 0:
            errors.append("Minimum selections cannot be negative")
    
    return errors

def render_price_input(label: str, key: str, default: float = 0.0) -> float:
    """Render price input with validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        price = st.number_input(
            label,
            min_value=0.0,
            max_value=500.0,
            value=default,
            step=0.01,
            key=key,
            help="Enter price (0.00 - 500.00)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Price Rules:
                ‚Ä¢ Must be non-negative
                ‚Ä¢ Maximum $500.00
                ‚Ä¢ Two decimal places
            </span>
        </div>
        """, unsafe_allow_html=True)
    return price

def render_time_input(label: str, key: str, default: str = "") -> str:
    """Render time input with 24-hour format validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        time = st.text_input(
            label,
            value=default,
            key=key,
            help="Enter time in 24-hour format (0000-2359)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Time Format:
                ‚Ä¢ 24-hour format (0000-2359)
                ‚Ä¢ Examples: 0900, 1430, 2200
            </span>
        </div>
        """, unsafe_allow_html=True)
    
2[0-3])([0-5]\d)$', time):
        st.error('Time must be in 24-hour format (0000-2359)')
    return time

def render_option_limits(min_label: str, max_label: str, key_prefix: str) -> tuple[int, int]:
    """Render min/max selection limits with validation"""
    col1, col2, col3 = st.columns([2, 2, 1])
    
    with col1:
        min_val = st.number_input(
            min_label,
            min_value=0,
            max_value=10,
            value=0,
            step=1,
            key=f"{key_prefix}_min"
        )
    
    with col2:
        max_val = st.number_input(
            max_label,
            min_value=min_val,
            max_value=10,
            value=max(min_val, 1),
            step=1,
            key=f"{key_prefix}_max"
        )
    
    with col3:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Selection Limits:
                ‚Ä¢ Min: 0-10 items
                ‚Ä¢ Max: Must be ‚â• Min
                ‚Ä¢ Used for option groups
            </span>
        </div>
        """, unsafe_allow_html=True)
    
    return min_val, max_val

```

## Peak Orders Analysis

```sql
SET myvars.location_id_var = 61;
SET myvars.location_id_var_2 = 66;

WITH order_level_data AS (
    SELECT 
        o.id AS order_id,
        o.location_id,
        o.status,
        1 AS order_quantity,
        m.name AS order_location,
        o.updated_at - INTERVAL '4 hours' AS order_date,
        DATE(o.updated_at - INTERVAL '4 hours') AS order_day,
        EXTRACT(HOUR FROM (o.updated_at - INTERVAL '4 hours')) AS order_hour
    FROM orders o
    LEFT JOIN markers m ON o.marker_id = m.id
    WHERE o.location_id IN (current_setting('myvars.location_id_var')::integer,current_setting('myvars.location_id_var_2')::integer)
        AND o.status > 0
        AND o.status != 6
),

daily_peaks AS (
    SELECT 
        'Daily Peak' as peak_type,
        order_location,
        order_day as peak_date,
        NULL as peak_hour,
        COUNT(*) as order_count
    FROM order_level_data
    GROUP BY order_location, order_day
    ORDER BY COUNT(*) DESC
    LIMIT 1
),

hourly_peaks AS (
    SELECT 
        'Hourly Peak' as peak_type,
        order_location,
        order_day as peak_date,
        order_hour as peak_hour,
        COUNT(*) as order_count
    FROM order_level_data
    GROUP BY order_location, order_day, order_hour
    ORDER BY COUNT(*) DESC
    LIMIT 1
)

SELECT * FROM daily_peaks
UNION ALL
SELECT * FROM hourly_peaks
ORDER BY peak_type; 
```

## Menu Cleanup

```sql
DO $$
DECLARE
    v_location_id INT := 79;
    v_item_name VARCHAR := 'Hamburger Steak';
    v_option_name VARCHAR := 'Meat Temperature';
    --v_option_item_name VARCHAR := 'Poached';
BEGIN
    -- Delete option items first
    DELETE FROM option_items 
    WHERE id IN (
        SELECT 
            DISTINCT oi.id AS option_item_id
        FROM locations l 
        INNER JOIN menus m ON m.location_id = l.id
        INNER JOIN categories c ON c.menu_id = m.id
        INNER JOIN items i ON i.category_id = c.id
        INNER JOIN options o ON o.item_id = i.id
        INNER JOIN option_items oi ON oi.option_id = o.id
        WHERE l.id = v_location_id
        AND i.name = v_item_name
        AND o.name = v_option_name
    );

    -- Then delete the options
    DELETE FROM options 
    WHERE id IN (
        SELECT 
            DISTINCT o.id AS option_id
        FROM locations l 
        INNER JOIN menus m ON m.location_id = l.id
        INNER JOIN categories c ON c.menu_id = m.id
        INNER JOIN items i ON i.category_id = c.id
        INNER JOIN options o ON o.item_id = i.id
        WHERE l.id = v_location_id
        AND i.name = v_item_name
        AND o.name = v_option_name
    );
END $$;

```

## Location Hours - Insert

```sql
INSERT INTO location_hours (location_id, day_of_week, open_time, close_time, created_at, updated_at)
VALUES
    (79, 'Monday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Tuesday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Wednesday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Thursday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Friday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Saturday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    (79, 'Sunday', '00:00:00', '23:59:59', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

```

## Location Hours - Query

```sql

SELECT 
	l.id AS location_id,
	l.name AS location_name
FROM locations l 
INNER JOIN location_hours lh on l.id = lh.location_id
WHERE 
	l.id IN (61)
	

```

## Location Hours - Update

```sql
UPDATE location_hours
SET 
    updated_at = CURRENT_TIMESTAMP,
    open_time = '11:00:00',
    close_time = '21:00:00'
WHERE 
    location_id = 62
    AND day_of_week = 'Monday';

```

## Location Hours - View

```sql
SELECT * FROM location_hours 

where location_id = 62


```

## Markers - Insert

```sql
INSERT INTO markers (id, created_at, updated_at, deleted_at, name, disabled, location_id)
VALUES
    (656, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, null, 'To-Go Orders', false, 79),
    (657, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, null, 'At the Turn Pickup', false, 79);
    
```

## Markers - View

```sql
SELECT * FROM markers order by id desc
```

## Menu Management - Delete Option Items

```sql
DO $$
DECLARE
    v_location_id INT := 79;
    --v_item_name VARCHAR := 'Three Egg Platter';
    --v_option_name VARCHAR := 'Toast Type';
    v_option_item_name VARCHAR := 'Poached';
BEGIN
    -- Delete option items first
    DELETE FROM option_items 
    WHERE id IN (
        SELECT 
            DISTINCT oi.id AS option_item_id
        FROM locations l 
        INNER JOIN menus m ON m.location_id = l.id
        INNER JOIN categories c ON c.menu_id = m.id
        INNER JOIN items i ON i.category_id = c.id
        INNER JOIN options o ON o.item_id = i.id
        INNER JOIN option_items oi ON oi.option_id = o.id
        WHERE l.id = v_location_id
        --AND i.name = v_item_name
        --AND o.name = v_option_name
        AND oi.name = v_option_item_name
    );

END $$;

```

## Menu Management - Delete Option Items then Options

```sql
DO $$
DECLARE
    v_location_id INT := 79;
    v_item_name VARCHAR := 'Hamburger Steak';
    v_option_name VARCHAR := 'Meat Temperature';
    --v_option_item_name VARCHAR := 'Poached';
BEGIN
    -- Delete option items first
    DELETE FROM option_items 
    WHERE id IN (
        SELECT 
            DISTINCT oi.id AS option_item_id
        FROM locations l 
        INNER JOIN menus m ON m.location_id = l.id
        INNER JOIN categories c ON c.menu_id = m.id
        INNER JOIN items i ON i.category_id = c.id
        INNER JOIN options o ON o.item_id = i.id
        INNER JOIN option_items oi ON oi.option_id = o.id
        WHERE l.id = v_location_id
        AND i.name = v_item_name
        AND o.name = v_option_name
    );

    -- Then delete the options
    DELETE FROM options 
    WHERE id IN (
        SELECT 
            DISTINCT o.id AS option_id
        FROM locations l 
        INNER JOIN menus m ON m.location_id = l.id
        INNER JOIN categories c ON c.menu_id = m.id
        INNER JOIN items i ON i.category_id = c.id
        INNER JOIN options o ON o.item_id = i.id
        WHERE l.id = v_location_id
        AND i.name = v_item_name
        AND o.name = v_option_name
    );
END $$;

```

## Menu Management - Show Option Items then Options

```sql
SELECT 
    i.name AS item_name,
    o.name AS option_name,
    oi.id AS option_item_id,
    oi.name AS option_item_name,
    oi.price AS option_item_price,
    o.*
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
INNER JOIN options o ON o.item_id = i.id
INNER JOIN option_items oi ON oi.option_id = o.id
WHERE l.id = 79
AND i.name = 'Hamburger Steak'
AND o.name = 'Meat Temperature'
--AND oi.name = 'Poached'
ORDER BY oi.name;
```

## Menu Management - Insert Items

```sql
INSERT INTO items
    (id, created_at, updated_at, deleted_at, name, description, price, category_id, disabled, seq_num)
VALUES
    (3760, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Miller Lite', 'Light pilsner known for its crisp, refreshing taste.', 7.0000, 533, false, 0),
    (3761, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Coors Light', 'Light beer with a smooth, easy-drinking flavor.', 7.0000, 533, false, 1),
    (3762, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Leinenkugel''s', 'Traditional Weiss beer with subtle hints of fruit and spice.', 7.0000, 533, false, 2),
    (3763, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'SweetWater 420', 'Well-balanced pale ale with a hint of citrus.', 7.0000, 533, false, 3),
    (3764, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'SweetWater IPA', 'Hoppy India Pale Ale with notes of pine and grapefruit.', 7.0000, 533, false, 4),
    (3765, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Tropicalia', 'Juicy, hop-forward IPA with tropical fruit flavors.', 7.0000, 533, false, 5),
    (3766, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bud Light', 'Light-bodied lager with a clean, crisp finish.', 7.0000, 533, false, 6),
    (3767, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Budweiser', 'Medium-bodied, flavorful, American-style lager.', 7.0000, 533, false, 7),
    (3768, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Corona', 'Pale lager with a refreshing, smooth taste.', 7.0000, 533, false, 8),
    (3769, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Corona Light', 'Light version of classic Corona, with a mild flavor.', 7.0000, 533, false, 9);


INSERT INTO items
    (id, created_at, updated_at, deleted_at, name, description, price, category_id, disabled, seq_num)
VALUES
    (3770, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'High Noon - Lemon', 'Vodka-based cocktail with a crisp lemon flavor.', 7.0000, 534, false, 0),
    (3771, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'High Noon - Lime', 'Vodka-based cocktail with a refreshing lime taste.', 7.0000, 534, false, 1),
    (3772, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'High Noon - Peach', 'Vodka-based cocktail with a sweet peach flavor.', 7.0000, 534, false, 2),
    (3773, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'High Noon - Pineapple', 'Vodka-based cocktail with a tropical pineapple twist.', 7.0000, 534, false, 3),
    (3774, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Long Drinks - Citrus', 'Gin-based cocktail with a burst of citrus flavor.', 7.0000, 534, false, 4),
    (3775, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Long Drinks - Cranberry', 'Gin-based cocktail with a tangy cranberry twist.', 7.0000, 534, false, 5),
    (3776, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Long Drinks - Zero Sugar Citrus', 'Zero-sugar version of the citrus gin cocktail.', 7.0000, 534, false, 6),
    (3777, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Long Drinks - Strong Citrus', 'Stronger, bolder version of the citrus gin cocktail.', 7.0000, 534, false, 7),
    (3778, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Long Drinks - Peach', 'Gin-based cocktail with a soft peach flavor.', 7.0000, 534, false, 8);


INSERT INTO categories (id, created_at, updated_at, deleted_at, name, description, menu_id, disabled, start_time, end_time, seq_num)
VALUES
(535, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Sparkling & Champagne', 'Wine - Sparkling & Champagne', 63, false, 0, 0, 17),
(536, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Riesling', 'Wine - Riesling', 63, false, 0, 0, 18),
(537, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Pinot Grigio', 'Wine - Pinot Grigio', 63, false, 0, 0, 19),
(538, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Sauvignon Blanc', 'Wine - Sauvignon Blanc', 63, false, 0, 0, 20),
(539, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Chardonnay', 'Wine - Chardonnay', 63, false, 0, 0, 21),
(540, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Pinot Noir', 'Wine - Pinot Noir', 63, false, 0, 0, 22),
(541, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Merlot', 'Wine - Merlot', 63, false, 0, 0, 23),
(542, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Cabernet', 'Wine - Cabernet', 63, false, 0, 0, 24),
(543, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Zinfandel & Shiraz', 'Wine - Zinfandel & Shiraz', 63, false, 0, 0, 25),
(544, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Wine - Interesting Reds', 'Wine - Interesting Reds', 63, false, 0, 0, 26);


INSERT INTO items
    (id, created_at, updated_at, deleted_at, name, description, price, category_id, disabled, seq_num)
VALUES
    --(3784, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'La Marca Prosecco ‚ÄúRos√©‚Äù', 'Veneto, Italy (Bottle)', 11.0000, 535, false, 0),
    --(3785, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars Prosecco', 'Veneto, Italy', 5.0000, 535, false, 1),
    --(3786, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Moet Imperial Brut', 'Champagne, France (Bottle)', 99.0000, 535, false, 2),
    (3787, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Moet Imperial ‚ÄúRos√©‚Äù', 'Champagne, France (Bottle)', 96.0000, 535, false, 3),
    (3788, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Piper Heidsieck Cuv√©e Brut', 'Champagne, France (Bottle)', 94.0000, 535, false, 4),
    (3789, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Veuve Clicquot Yellow Label', 'Champagne, France (Bottle)', 99.0000, 535, false, 5),
    (3790, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Pierre Sparr', 'Alsace, France', 6.0000, 536, false, 0),
    (3791, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Kung Foo Girl', 'Columbia Valley, WA', 4.0000, 536, false, 1),
    (3792, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Santa Margherita', 'Valdadige, Italy', 7.0000, 537, false, 0),
    (3793, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars', 'California', 6.0000, 538, false, 0),
    (3794, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Hogue Cellars', 'Columbia Valley, Washington', 5.0000, 538, false, 1),
    (3795, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Whitehaven', 'Marlborough, New Zealand', 5.0000, 538, false, 2),
    (3796, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Kim Crawford', 'South Island, New Zealand', 7.0000, 538, false, 3),
    (3797, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars', 'California', 6.0000, 539, false, 0),
    (3798, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Canyon Road', 'California', 4.0000, 539, false, 1),
    (3799, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Flowers', 'Sonoma Coast, California (Bottle)', 58.0000, 539, false, 2),
    (3800, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Kendall-Jackson Vintner''s Reserve', 'California', 6.0000, 539, false, 3),
    (3801, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Ramey Cellars', 'Russian River Valley, WS 94pts (Bottle)', 74.0000, 539, false, 4),
    (3802, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Sonoma-Cutrer', 'Sonoma County, California', 7.0000, 539, false, 5),
    (3803, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Cakebread Cellars', 'Napa, California (Bottle)', 78.0000, 539, false, 6),
    (3804, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Crossbarn', 'Sonoma Coast, California (Bottle)', 42.0000, 539, false, 7),
    (3805, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'DAOU Vineyards', 'Paso Robles, California (Bottle)', 42.0000, 539, false, 8),
    (3806, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Patz & Hall', 'Sonoma Coast, California (Bottle)', 46.0000, 539, false, 9),
    (3807, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Quilt', 'Napa Valley, California (Bottle)', 58.0000, 539, false, 10),
    (3808, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Rombauer', 'Carneros, California', 12.0000, 539, false, 11),
    (3809, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Rombauer ‚ÄúProprietor Select‚Äù', 'Carneros, WS 92pts (Bottle)', 99.0000, 539, false, 12),
    (3810, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars', 'California', 6.0000, 540, false, 0),
    (3811, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Meiomi', 'California', 6.0000, 540, false, 1),
    (3812, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Siduri', 'Willamette Valley, Oregon', 6.0000, 540, false, 2),
    (3813, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Flowers', 'Russian River Valley, California (Bottle)', 62.0000, 540, false, 3),
    (3814, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Sonoma-Cutrer', 'Russian River Valley, California', 10.0000, 540, false, 4),
    (3815, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Belle Glos ‚ÄúLas Alturas‚Äù', 'St. Lucia Highlands, California (Bottle)', 99.0000, 540, false, 5),
    (3816, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Walt ‚ÄúBlue Jay‚Äù', 'Anderson Valley, WS 93pts', 11.0000, 540, false, 6),
    (3817, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars', 'California (Bottle)', 38.0000, 541, false, 0),
    (3818, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Duckhorn', 'Napa Valley, California (Bottle)', 99.0000, 541, false, 1),
    (3819, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Emmolo', 'Napa Valley, California', 5.0000, 541, false, 2),
    (3820, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Canyon Road', 'California', 4.0000, 542, false, 0),
    (3821, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Josh Cellars', 'California', 6.0000, 542, false, 1),
    (3822, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Trefethen Family', 'Oak Knoll District, California (Bottle)', 66.0000, 542, false, 2),
    (3823, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Grgich Hills Estate', 'Napa Valley, California (Bottle)', 99.0000, 542, false, 3),
    (3824, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Groth', 'Oakville, California (Bottle)', 99.0000, 542, false, 4),
    (3825, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Silver Oak', 'Alexander Valley, California (Bottle)', 99.0000, 542, false, 5),
    (3826, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Freemark Abbey', 'Napa Valley, California (Bottle)', 99.0000, 542, false, 6),
    (3827, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Caymus', 'Napa Valley, California', 19.0000, 542, false, 7),
    (3828, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Daou ‚ÄúSoul of a Lion‚Äù', 'Napa Valley, RP 97pts', 24.0000, 542, false, 8),
    (3829, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Stag‚Äôs Leap ‚ÄúArtemis‚Äù', 'Napa Valley, California (Bottle)', 99.0000, 542, false, 9),
    (3830, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Daou Reserve', 'Paso Robles, California (Bottle)', 54.0000, 542, false, 10),
    (3831, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'The Prisoner', 'Napa Valley, California', 9.0000, 542, false, 11),
    (3832, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Austin Hope', 'Paso Robles, California', 15.0000, 542, false, 12),
    (3833, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Quilt', 'Napa Valley, California', 7.0000, 542, false, 13),
    (3834, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Terra D‚ÄôOro Zinfandel', 'Amador County, California', 6.0000, 543, false, 0),
    (3835, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Seghesio Family Vineyards', 'Sonoma, WS 92pts (Bottle)', 54.0000, 543, false, 1),
    (3836, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Rombauer Zinfandel', 'Napa County, California (Bottle)', 68.0000, 543, false, 2),
    (3837, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Two Hands Angels‚Äô Share Shiraz', 'Mclaren Vale, AUS', 7.0000, 543, false, 3),
    (3838, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Ch. Mongravey Margaux', 'Margaux, Bordeaux, France (Bottle)', 78.0000, 544, false, 0),
    (3839, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Daou Seventeen Forty Red', 'Paso Robles, California (Bottle)', 99.0000, 544, false, 1),
    (3840, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Red Schooner Red Transit #2', 'California (Bottle)', 50.0000, 544, false, 2),
    (3841, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Caymus Suison Grand Durif', 'Suison Valley, California (Bottle)', 54.0000, 544, false, 3),
    (3842, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Leviathan Red Wine', 'California (Bottle)', 48.0000, 544, false, 4),
    (3843, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Chateau La Nerthe', 'Ch√¢teauneuf-Du-Pape, RV, France (Bottle)', 9.0000, 544, false, 5);


INSERT INTO options
    (id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled)
VALUES
    (3696, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3785, false),
    (3697, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3790, false),
    (3698, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3791, false),
    (3699, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3792, false),
    (3700, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3793, false),
    (3701, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3794, false),
    (3702, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3795, false),
    (3703, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3796, false),
    (3704, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3797, false),
    (3705, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3798, false),
    (3706, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3800, false),
    (3707, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3802, false),
    (3708, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3808, false),
    (3709, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3810, false),
    (3710, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3811, false),
    (3711, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3812, false),
    (3712, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3814, false),
    (3713, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3816, false),
    (3714, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3817, false),
    (3715, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3819, false),
    (3716, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3820, false),
    (3717, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3821, false),
    (3718, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3827, false),
    (3719, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3828, false),
    (3720, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3831, false),
    (3721, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3832, false),
    (3722, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3834, false),
    (3723, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Options', 'Options', 0, 0, 3837, false);


INSERT INTO option_items
    (id, created_at, updated_at, deleted_at, name, description, price, option_id)
VALUES
    (58515, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 Oz', '6 Oz', 3.00, 3696),
    (58516, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 Oz', '9 Oz', 7.00, 3696),
    (58517, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 25.00, 3696),

"id"	"created_at"	"updated_at"	"deleted_at"	"name"	"description"	"price"	"option_id"	"disabled"
58514	"2024-05-10 12:42:16.151387+00"	"2024-05-10 12:42:16.151387+00"		"Chocolate Fudge Brownie"	"Chocolate Fudge Brownie"	0.00	3689	false


INSERT INTO option_items
    (id, created_at, updated_at, deleted_at, name, description, price, option_id, disabled)
VALUES
    (58515, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 3.00, 3696, false),
    (58516, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 7.00, 3696, false),
    (58517, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 25.00, 3696, false),
    (58518, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3697, false),
    (58519, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3697, false),
    (58520, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3697, false),
    (58521, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 3.00, 3698, false),
    (58522, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 6.00, 3698, false),
    (58523, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 22.00, 3698, false),
    (58524, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 5.00, 3699, false),
    (58525, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 11.00, 3699, false),
    (58526, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 39.00, 3699, false),
    (58527, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3700, false),
    (58528, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3700, false),
    (58529, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3700, false),
    (58530, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 3.00, 3701, false),
    (58531, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 7.00, 3701, false),
    (58532, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 25.00, 3701, false),
    (58533, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3702, false),
    (58534, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 8.00, 3702, false),
    (58535, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 29.00, 3702, false),
    (58536, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 5.00, 3703, false),
    (58537, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 11.00, 3703, false),
    (58538, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 39.00, 3703, false),
    (58539, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3704, false),
    (58540, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3704, false),
    (58541, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3704, false),
    (58542, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 3.00, 3705, false),
    (58543, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 6.00, 3705, false),
    (58544, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 22.00, 3705, false),
    (58545, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3706, false),
    (58546, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3706, false),
    (58547, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3706, false),
    (58548, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 6.00, 3707, false),
    (58549, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 12.00, 3707, false),
    (58550, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 43.00, 3707, false),
    (58551, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 10.00, 3708, false),
    (58552, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 21.00, 3708, false),
    (58553, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 74.00, 3708, false),
    (58554, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3709, false),
    (58555, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3709, false),
    (58556, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3709, false),
    (58557, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3710, false),
    (58558, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3710, false),
    (58559, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3710, false),
    (58560, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 5.00, 3711, false),
    (58561, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 11.00, 3711, false),
    (58562, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 36.00, 3711, false),
    (58563, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 8.00, 3712, false),
    (58564, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 17.00, 3712, false),
    (58565, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 60.00, 3712, false),
    (58566, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 9.00, 3713, false),
    (58567, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 19.00, 3713, false),
    (58568, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 67.00, 3713, false),
    (58569, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3715, false),
    (58570, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 8.00, 3715, false),
    (58571, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 29.00, 3715, false),
    (58572, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 3.00, 3716, false),
    (58573, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 7.00, 3716, false),
    (58574, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 22.00, 3716, false),
    (58575, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3717, false),
    (58576, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3717, false),
    (58577, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3717, false),
    (58578, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 17.00, 3718, false),
    (58579, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 35.00, 3718, false),
    (58580, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 99.00, 3718, false),
    (58581, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 7.00, 3720, false),
    (58582, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 15.00, 3720, false),
    (58583, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 53.00, 3720, false),
    (58584, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 13.00, 3721, false),
    (58585, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 27.00, 3721, false),
    (58586, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 95.00, 3721, false),
    (58587, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 4.00, 3722, false),
    (58588, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 9.00, 3722, false),
    (58589, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 32.00, 3722, false),
    (58590, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '6 oz', '6 oz', 6.00, 3723, false),
    (58591, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, '9 oz', '9 oz', 12.00, 3723, false),
    (58592, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL, 'Bottle', 'Bottle', 43.00, 3723, false);

```

## Menu Management - Menu Items with Options

```sql

SELECT 
	l.id AS location_id,
	l.name AS location_name,
	m.id AS menu_id,
	m.name AS menu_name,
	c.id as category_id, 
	c.name as category_name, 
	c.seq_num,
	i.id AS item_id,
	i.name AS item_name,
	o.id AS option_id, 
	o.name AS option_name,
	oi.id AS option_item_id,
	oi.name AS option_item_name
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
LEFT JOIN options o on o.item_id = i.id
LEFT JOIN option_items oi ON oi.option_id = o.id
	    WHERE l.id = 62
      --AND c.name = 'Signature Sandwiches'
      AND oi.name LIKE ('%Risotto%')
	--And oi.name = 'Wedge Salad'
    --and c.id = 529
	--i.id = 3522 AND

	--o.id = 3500
	--AND oi.name LIKE ('%Rye%')
	order by c.seq_num, i.seq_num
--SELECT * FROM option_items --where id IN (13160, 13211, 13222)


```

## Menu Management - Menu JSON

```json

```

## Menu Management - Open Orders

```sql

SELECT
    l.id,
	l.name as location_name,
	o.id AS order_id,
	o.status AS order_status,
	o.total AS order_total,
	u.id AS user_id,
	u.phone AS user_phone,
	u.email AS user_email,
	o.updated_at - INTERVAL '7 hours' AS order_date,
	o.tip as tip,
	d.amount as discount_amount
FROM orders o
INNER JOIN users u ON o.customer_id = u.id
INNER JOIN locations l ON l.id = o.location_id
LEFT JOIN discounts d on d.order_id = o.id
WHERE l.id NOT IN (32,29)
  AND u.id NOT IN (19,644,928,174)
  AND o.status NOT IN (0,6)
  AND (o.updated_at - INTERVAL '7 hours')::date = CURRENT_DATE
  --AND tip > 0
 ORDER by o.updated_at desc

```

## Menu Management - Option Min Max Test

```sql
SELECT 
    i.name AS item_name,
    o.name AS option_name,
    oi.id AS option_item_id,
    oi.name AS option_item_name,
    oi.price AS option_item_price,
    o.*
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
INNER JOIN options o ON o.item_id = i.id
INNER JOIN option_items oi ON oi.option_id = o.id
WHERE l.id = 79
AND c.name = 'Brunch - Menu'
--AND i.name = 'Breakfast Burrito'
AND o.name = 'Side Choice'
AND o.min = 2
AND o.max = 2
ORDER BY oi.name;
```

## Menu Management - Option Min Max Update

```sql
UPDATE options
SET min = 0,
    max = 0
WHERE id IN (
    SELECT DISTINCT o.id
    FROM locations l 
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    INNER JOIN options o ON o.item_id = i.id
    INNER JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = 79
    AND c.name = 'Brunch - Menu'
    AND o.name = 'Side Choice'
    AND o.min = 2
    AND o.max = 2
);
```

## Menu Management - Replicate Option and Option Items Copy

```sql
/*
This script copies options and option items from one menu item to another.
It performs the following steps:
1. Finds the source item ID ('Chuck Roast') and target item ID ('Seared Sea Scallops')
2. Gets the next available option ID to avoid conflicts
3. Copies all options from the source item to the target item, preserving attributes
4. Copies all option items associated with those options to the new options
5. Maintains referential integrity by linking new option items to their new parent options

This is useful when creating a new menu item that needs the same option structure
as an existing item.
*/

DO $$
DECLARE
    old_item_id int;
    new_item_id int;
    new_option_id int;
BEGIN

-- Old Item
SELECT i.id INTO old_item_id
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
WHERE 
    l.id = 62
    AND c.id = 529
    AND i.name = 'Chuck Roast';

RAISE NOTICE 'Old item ID: %', old_item_id;

-- New Item
SELECT i.id INTO new_item_id
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
WHERE 
    l.id = 62
    AND c.id = 529
    AND i.name = 'Seared Sea Scallops';

RAISE NOTICE 'New item ID: %', new_item_id;

-- Exit if no items were found
IF old_item_id IS NULL OR new_item_id IS NULL THEN 
    RAISE EXCEPTION 'One or both items not found for the specified criteria';
END IF;

-- Get the next available option id
SELECT COALESCE(MAX(id), 0) + 1 INTO new_option_id FROM options;
RAISE NOTICE 'Next available option ID: %', new_option_id;

-- Insert new options and store their old and new IDs
WITH inserted_options AS (
    INSERT INTO options (id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled)
    SELECT 
        new_option_id + ROW_NUMBER() OVER (ORDER BY id) - 1,
        NOW(),
        NOW(), 
        deleted_at, 
        name,
        description,
        min,
        max,
        new_item_id,
        disabled
    FROM options
    WHERE item_id = old_item_id
    RETURNING id AS new_option_id, 
        (SELECT id FROM options WHERE item_id = old_item_id AND name = options.name) AS old_option_id
)
-- Insert option items for each new option
INSERT INTO option_items (id, created_at, updated_at, deleted_at, name, description, price, option_id, disabled)
SELECT 
    (SELECT COALESCE(MAX(id), 0) + 1 FROM option_items) + ROW_NUMBER() OVER (ORDER BY oi.id),
    NOW(),
    NOW(),
    oi.deleted_at,
    oi.name,
    oi.description,
    oi.price,
    io.new_option_id,
    oi.disabled
FROM option_items oi
INNER JOIN inserted_options io ON io.old_option_id = oi.option_id;

RAISE NOTICE 'Successfully completed option and option item replication';

END $$;

```

## Menu Management - Replicate Option and Option Items

```sql
DO $$
DECLARE
    old_item_id int;
    new_item_id int;
BEGIN

-- Old Item
SELECT i.id INTO old_item_id
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
WHERE 
    l.id = 62
    AND c.name = 'Entrees'
    AND i.name = 'IHCC Classic Filet Mignon';

-- New Item
SELECT i.id INTO new_item_id
FROM locations l 
INNER JOIN menus m ON m.location_id = l.id
INNER JOIN categories c ON c.menu_id = m.id
INNER JOIN items i ON i.category_id = c.id
WHERE 
    l.id = 62
    AND c.name = 'Entrees'
    AND i.name = 'Seared Sea Scallops';

-- Exit if no item was found
IF old_item_id IS NULL THEN 
    RAISE EXCEPTION 'No item found for the specified criteria';
END IF;

-- Directly insert into the 'options' table, duplicating the existing options for a new item
INSERT INTO options (id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled)
SELECT 
    (SELECT COALESCE(MAX(id), 0) + 1 FROM options) + ROW_NUMBER() OVER (ORDER BY id),
    NOW(),
    NOW(), 
    deleted_at, 
    name,
    description,
    min,
    max,
    new_item_id,
    disabled
FROM options
WHERE item_id = old_item_id;

END $$;

```

## Menu Management - Replicate Options

```sql

DECLARE
    old_item_id INT := 3056;
    new_item_id INT := 3848;
BEGIN
    -- Create a temporary table with the same structure as 'options'
    CREATE TEMP TABLE temp_options (LIKE options INCLUDING ALL);

    -- Insert into the temporary table, duplicating the existing option for a new item
    INSERT INTO temp_options (id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled)
    SELECT 
        (SELECT COALESCE(MAX(id), 0) + 1 FROM temp_options), -- Use COALESCE in case table is empty
        NOW(), -- Current time for created_at
        NOW(), -- Current time for updated_at
        deleted_at, 
        name, 
        description, 
        min, 
        max, 
        new_item_id, -- Link this entry to the new item
        disabled
    FROM options
    WHERE item_id = old_item_id
    LIMIT 1
    
    SELECT * FROM   temp_options;
    
    -- Clean up: Drop the temporary table
    --DROP TABLE temp_options;


```

## Menu Management - Update Option Item Name

```sql
UPDATE option_items
SET name = 'Asiago-Chive Risotto'
WHERE id IN (
    SELECT oi.id
    FROM locations l
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o ON o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = 62
      --AND c.id = 440
      AND oi.name = 'Butternut Squash Risotto'
);


SELECT oi.id
    FROM locations l
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o ON o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = 62
      --AND c.id = 440
      AND oi.name = 'Butternut Squash Risotto'
```

## Menu Management - Update Option Item Prices

```sql
WITH items_to_update AS (
    SELECT i.id AS item_id,
           i.name AS item_name,
           o.id AS option_id,
           o.name AS option_name,
           oi.id AS option_item_id,
           oi.name AS option_item_name,
           oi.price
    FROM locations l
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o ON o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = 62
      --AND c.id = 440

      --AND c.name = 'Salads'
      AND o.name = 'Extras'
      --AND oi.name IN ('Blackened Shrimp')
      order by oi.name, oi.price
)
UPDATE option_items
SET price = 10.00  -- Set your desired price here
WHERE id IN (SELECT option_item_id FROM items_to_update);
```

## Menu Management - Update Selected Option

```sql

-- Step 1: Display menu items with options
WITH menu_items AS (
    SELECT 
        l.id AS location_id,
        l.name AS location_name,
        m.id AS menu_id,
        m.name AS menu_name,
        c.id as category_id, 
        c.name as category_name, 
        c.seq_num,
        i.id AS item_id,
        i.name AS item_name,
        o.id AS option_id, 
        o.name AS option_name,
        oi.id AS option_item_id,
        oi.name AS option_item_name
    FROM locations l 
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o on o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = 61
    AND c.name = 'Signature Sandwiches'
    ORDER BY c.seq_num, i.seq_num
)
SELECT * FROM menu_items;

-- Step 2: Prompt for item selection (simulated with a variable)
\set selected_item_id :PROMPT 'Enter the item_id you want to modify: '

-- Step 3: Display options for the selected item
SELECT option_id, option_name, option_item_id, option_item_name
FROM menu_items
WHERE item_id = :selected_item_id;

-- Step 4: Prompt for option to disable (simulated with a variable)
\set option_to_disable :PROMPT 'Enter the option_item_id you want to disable: '

-- Step 5: Disable the selected option
UPDATE option_items
SET is_active = FALSE
WHERE id = :option_to_disable;

-- Step 6: Confirm the update
SELECT *
FROM option_items
WHERE id = :option_to_disable;

```

## Menu Management - Clean Items and Options

```sql

SELECT setval(pg_get_serial_sequence('public.items', 'id'), (SELECT MAX(id) FROM public.items) + 1);
SELECT setval(pg_get_serial_sequence('public.options', 'id'), (SELECT MAX(id) FROM public.options) + 1);
SELECT setval(pg_get_serial_sequence('public.option_items', 'id'), (SELECT MAX(id) FROM public.option_items) + 1);
```

## Menu Management - Copy All Options From Item

```sql
DO $$
DECLARE
    v_location_id INT := 75;
    v_old_category_name VARCHAR := 'Deli Selections';
    v_old_item_name VARCHAR := 'Dinner Salad';
    v_new_category_name VARCHAR := 'Deli Selections';
    v_new_item_name VARCHAR := 'Chef Salad';
    old_item_id INT;
    new_item_id INT;
    max_option_id INT;
    max_option_item_id INT;
BEGIN
    -- Fetch old item ID
    SELECT i.id INTO old_item_id
    FROM locations l
    JOIN menus m ON m.location_id = l.id
    JOIN categories c ON c.menu_id = m.id
    JOIN items i ON i.category_id = c.id
    WHERE l.id = v_location_id
      AND c.name = v_old_category_name
      AND i.name = v_old_item_name;

    -- Fetch new item ID
    SELECT i.id INTO new_item_id
    FROM locations l
    JOIN menus m ON m.location_id = l.id
    JOIN categories c ON c.menu_id = m.id
    JOIN items i ON i.category_id = c.id
    WHERE l.id = v_location_id
      AND c.name = v_new_category_name
      AND i.name = v_new_item_name;

    -- Validate item IDs
    IF old_item_id IS NULL OR new_item_id IS NULL THEN
        RAISE EXCEPTION 'No item found for the specified criteria';
    END IF;

    -- Get current maximum IDs
    SELECT COALESCE(MAX(id), 0) INTO max_option_id FROM options;
    SELECT COALESCE(MAX(id), 0) INTO max_option_item_id FROM option_items;

    -- Insert new options
    WITH new_options AS (
        INSERT INTO options (
            id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled
        )
        SELECT 
            max_option_id + ROW_NUMBER() OVER (ORDER BY id),
            NOW(),
            NOW(),
            deleted_at,
            name,
            description,
            min,
            max,
            new_item_id,
            disabled
        FROM options
        WHERE item_id = old_item_id
        RETURNING id, name
    )
    -- Insert new option items
    INSERT INTO option_items (
        id, created_at, updated_at, deleted_at, name, description, price, option_id, disabled
    )
    SELECT 
        max_option_item_id + ROW_NUMBER() OVER (ORDER BY oi.id),
        NOW(),
        NOW(),
        oi.deleted_at,
        oi.name,
        oi.description,
        oi.price,
        no.id AS option_id,
        oi.disabled
    FROM option_items oi
    JOIN options o ON o.id = oi.option_id
    JOIN new_options no ON o.name = no.name
    WHERE o.item_id = old_item_id;
END $$;

```

## Menu Management - Copy One Option From Item

```sql
DO $$
DECLARE
    v_location_id INT := 75;
    v_old_category_name VARCHAR := 'Deli Selections';
    v_old_item_name VARCHAR := 'Caesar Salad';
    v_old_option_name VARCHAR := 'Remove Options';
    v_new_category_name VARCHAR := 'Deli Selections';
    v_new_item_name VARCHAR := 'Traditional Club';
    old_item_id INT;
    new_item_id INT;
    max_option_id INT;
    max_option_item_id INT;
BEGIN
    -- Fetch old item ID
    SELECT i.id INTO old_item_id
    FROM locations l
    JOIN menus m ON m.location_id = l.id
    JOIN categories c ON c.menu_id = m.id
    JOIN items i ON i.category_id = c.id
    WHERE l.id = v_location_id
      AND c.name = v_old_category_name
      AND i.name = v_old_item_name;

    -- Fetch new item ID
    SELECT i.id INTO new_item_id
    FROM locations l
    JOIN menus m ON m.location_id = l.id
    JOIN categories c ON c.menu_id = m.id
    JOIN items i ON i.category_id = c.id
    WHERE l.id = v_location_id
      AND c.name = v_new_category_name
      AND i.name = v_new_item_name;

    -- Validate item IDs
    IF old_item_id IS NULL OR new_item_id IS NULL THEN
        RAISE EXCEPTION 'No item found for the specified criteria';
    END IF;

    -- Get current maximum IDs
    SELECT COALESCE(MAX(id), 0) INTO max_option_id FROM options;
    SELECT COALESCE(MAX(id), 0) INTO max_option_item_id FROM option_items;

    -- Insert new options
    WITH new_options AS (
        INSERT INTO options (
            id, created_at, updated_at, deleted_at, name, description, min, max, item_id, disabled
        )
        SELECT 
            max_option_id + ROW_NUMBER() OVER (ORDER BY id),
            NOW(),
            NOW(),
            deleted_at,
            name,
            description,
            min,
            max,
            new_item_id,
            disabled
        FROM options
        WHERE item_id = old_item_id
        AND name = v_old_option_name
        RETURNING id, name
    )
    -- Insert new option items
    INSERT INTO option_items (
        id, created_at, updated_at, deleted_at, name, description, price, option_id, disabled
    )
    SELECT 
        max_option_item_id + ROW_NUMBER() OVER (ORDER BY oi.id),
        NOW(),
        NOW(),
        oi.deleted_at,
        oi.name,
        oi.description,
        oi.price,
        no.id AS option_id,
        oi.disabled
    FROM option_items oi
    JOIN options o ON o.id = oi.option_id
    JOIN new_options no ON o.name = no.name
    WHERE o.item_id = old_item_id
    AND o.name = v_old_option_name;
END $$;

```

## Menu Management - Menu Cleanup Delete

```sql
DO $$
DECLARE
    v_location_id INT := 75;
    v_item_name VARCHAR := 'Three Egg Platter';
    v_option_name VARCHAR := 'Remove Options';
    v_option_item_name VARCHAR := 'No Cucumbers';
BEGIN


-- Delete options items
DELETE FROM option_items 
WHERE id IN (
    SELECT 
        DISTINCT oi.id AS option_item_id
    FROM locations l 
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o on o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = v_location_id
    AND i.name = v_item_name
    AND o.name = v_option_name
    AND oi.name = v_option_item_name
);

END $$;
-- Delete options
DELETE FROM options 
WHERE id IN (
    SELECT 
        DISTINCT o.id AS option_id
    FROM locations l 
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o on o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE l.id = v_location_id
    AND i.name = v_item_name
    --AND o.name = v_option_name
    --AND oi.name = v_option_item_name
);



-- Delete items
DELETE FROM items 
WHERE id IN (
    SELECT 
        DISTINCT i.id AS item_id
    FROM locations l 
    INNER JOIN menus m ON m.location_id = l.id
    INNER JOIN categories c ON c.menu_id = m.id
    INNER JOIN items i ON i.category_id = c.id
    LEFT JOIN options o on o.item_id = i.id
    LEFT JOIN option_items oi ON oi.option_id = o.id
    WHERE (m.location_id IS NULL OR l.id = v_location_id)
    AND (i.name IS NULL OR i.name = v_item_name)
    AND (o.name IS NULL OR o.name = v_option_name)
    AND (oi.name IS NULL OR oi.name = v_option_item_name)
);

END $$;

```

