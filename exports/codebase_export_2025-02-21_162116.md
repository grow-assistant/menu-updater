# Menu Updater Codebase Export

Generated on: 2025-02-21 16:21:16

# Project Overview

# Menu Updater

An AI-powered tool for Swoop customers to manage their restaurant menus through natural language queries and updates.

## System Overview

### Core Components

1. **Frontend (Streamlit)**
   - Interactive web interface with sidebar navigation
   - Common operations quick-access panel
   - Operation history display (last 5 operations)
   - Dark/light theme support
   - Real-time chat interface for natural language interactions

2. **Database (PostgreSQL)**
   - Hierarchical menu structure:
     ```
     Location
     ‚îî‚îÄ‚îÄ Menu
         ‚îî‚îÄ‚îÄ Category (with time ranges)
             ‚îî‚îÄ‚îÄ Item
                 ‚îî‚îÄ‚îÄ Option Group
                     ‚îî‚îÄ‚îÄ Option Items
     ```
   - All entities include:
     - Timestamps (created_at, updated_at, deleted_at)
     - Soft deletion via 'disabled' flag
     - Sequential ordering (seq_num) where applicable

3. **AI Integration (OpenAI)**
   - Natural language understanding for menu queries
   - Context-aware responses using operation history
   - Function calling for structured operations
   - Token management and conversation history

4. **Operation Management**
   - Location-specific operation storage
   - Common queries and updates
   - Operation history tracking (50 entries)
   - Template-based query generation

### Key Features

1. **Menu Structure**
   - Multi-location support
   - Time-based menu categories
   - Hierarchical item organization
   - Flexible option configurations
   - Price and availability management

2. **Operation Types**
   - View all active menu items
   - Search items by name/category
   - View time-based menu items
   - Update item prices
   - Enable/disable items
   - Modify descriptions
   - Manage option configurations

3. **Data Storage**
   - Location Settings (JSON)
     ```json
     {
       "common_operations": {
         "queries": [...],
         "updates": [...]
       },
       "operation_history": [
         {
           "timestamp": "2025-02-20T22:07:06Z",
           "operation_type": "query",
           "operation_name": "View Menu Items",
           "query_template": "SELECT ...",
           "result_summary": "Found 15 items"
         }
       ]
     }
     ```

4. **Validation Rules**
   - Non-negative prices
   - Valid time ranges (0-2359)
   - Required relationships maintained
   - Soft deletion preferred
   - Option constraints enforced

## Development Setup

1. **Clone the Repository:**
   ```bash
   git clone https://github.com/grow-assistant/menu-updater.git
   cd menu-updater
   ```

2. **Set Up Python Environment:**
   - Use Python 3.8 or higher
   - Create and activate a virtual environment (recommended)

3. **Set Up PostgreSQL:**
   - Install PostgreSQL
   - Create a new database for the project

4. **Configure Environment Variables:**
   Create a `.env` file with:
   ```
   DB_NAME=your_db_name
   DB_USER=your_db_user
   DB_PASSWORD=your_db_password
   DB_SERVER=localhost
   OPENAI_API_KEY=your_openai_key
   ```

5. **Install Dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

6. **Run the App:**
   ```bash
   streamlit run app.py
   ```
   The app will be available at http://localhost:8501

## Database Schema

### Key Tables

1. **locations**
   - id, name, description, timezone
   - settings (JSON for operations/history)
   - tax_rate, active/disabled flags

2. **menus**
   - id, name, description, location_id
   - disabled flag

3. **categories**
   - id, name, description, menu_id
   - start_time/end_time for availability
   - seq_num for ordering
   - disabled flag

4. **items**
   - id, name, description, price
   - category_id, seq_num
   - disabled flag

5. **options**
   - id, name, description
   - min/max selections
   - item_id, disabled flag

6. **option_items**
   - id, name, description, price
   - option_id, disabled flag

---



# Source Code

## App

```python
import streamlit as st
from utils.config import db_credentials, MAX_TOKENS_ALLOWED, MAX_MESSAGES_TO_OPENAI, TOKEN_BUFFER
from utils.system_prompts import get_final_system_prompt
from utils.chat_functions import run_chat_sequence, clear_chat_history, count_tokens, prepare_sidebar_data
from utils.database_functions import (
    get_db_connection,
    execute_menu_query,
    database_schema_dict
)
from utils.function_calling_spec import functions
from utils.helper_functions import save_conversation
from utils.ui_components import (
    render_price_input,
    render_time_input,
    render_option_limits,
    validate_menu_update
)
from assets.dark_theme import dark
from assets.light_theme import light
from assets.made_by_sdw import made_by_sdw
import pandas as pd





if __name__ == "__main__":

    # Initialize session state variables
    if "operation" not in st.session_state:
        st.session_state["operation"] = None

    if "selected_location_id" not in st.session_state:
        st.session_state["selected_location_id"] = None

    if "full_chat_history" not in st.session_state:
        st.session_state["full_chat_history"] = [{"role": "system", "content": get_final_system_prompt(db_credentials=db_credentials)}]

    if "api_chat_history" not in st.session_state:
        st.session_state["api_chat_history"] = [{"role": "system", "content": get_final_system_prompt(db_credentials=db_credentials)}]

    ########### A. SIDEBAR ###########

    # Add location selector at the top of sidebar
    st.sidebar.title("üìç Location Selection")
    try:
        location_query = """
            SELECT id, name 
            FROM locations 
            WHERE deleted_at IS NULL 
            ORDER BY id DESC
        """
        query_result = execute_menu_query(location_query)
        
        if query_result["success"] and query_result["results"]:
            locations = query_result["results"]  # This is now a list of dicts with 'id' and 'name' keys
            
            # Create a list of location options in "id - name" format
            location_options = ["All"] + [f"{loc['id']} - {loc['name']}" for loc in locations]
            
            # Find the index of location 16 in the options list
            default_index = next((i for i, opt in enumerate(location_options) if opt.startswith("16 -")), 0)
            
            selected_location = st.sidebar.selectbox(
                "Select Location",
                options=location_options,
                index=default_index
            )
            
            # Extract the location ID from the selection
            if selected_location != "All":
                selected_location_id = int(selected_location.split(" - ")[0])
                st.session_state["selected_location_id"] = selected_location_id
            else:
                st.session_state["selected_location_id"] = None

        else:
            st.sidebar.error("No locations found in database")
            
    except Exception as e:
        st.sidebar.error(f"Error loading locations: {str(e)}")

    st.sidebar.markdown("---")  # Add a visual separator

    # Prepare data for the sidebar dropdowns
    sidebar_data = prepare_sidebar_data(database_schema_dict)
    st.sidebar.markdown("<div class='made_by'>Made by SDWüîã</div>", unsafe_allow_html=True)

    ### MENU OPERATIONS ###
    st.sidebar.title("üçΩÔ∏è Menu Operations")
    
    # Add custom CSS for tooltips
    st.markdown("""
        <style>
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            background-color: #555;
            color: #fff;
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        </style>
    """, unsafe_allow_html=True)
    
    # All operations are now handled through chat interface
    # Users can query menu items by asking in the chat

    # Apply dark theme by default
    st.markdown(dark, unsafe_allow_html=True)

    ########### B. CHAT INTERFACE ###########
    
    ### TITLE ###
    st.title("Swoop AI Assistant")

    ### CHAT FACILITATION ###
    if (prompt := st.chat_input("What do you want to know?")) is not None:
        # Add the user message to chat history
        st.session_state.full_chat_history.append({"role": "user", "content": prompt})
        st.session_state.api_chat_history.append({"role": "user", "content": prompt})

    # Display previous chat messages from full_chat_history (ignore system prompt message)
    for message in st.session_state["full_chat_history"][1:]:
        if message["role"] == "user":
            st.chat_message("user", avatar='üßë‚Äçüíª').write(message["content"])
        elif message["role"] == "assistant":
            st.chat_message("assistant", avatar='ü§ñ').write(message["content"])

    if st.session_state["api_chat_history"][-1]["role"] != "assistant":
        with st.spinner("‚åõConnecting to AI model..."):
            # Send only the most recent messages to OpenAI from api_chat_history
            recent_messages = st.session_state["api_chat_history"][-MAX_MESSAGES_TO_OPENAI:]
            
            # Let the AI model handle operation detection
            new_message = run_chat_sequence(recent_messages, functions)
            
            # Add this latest message to both api_chat_history and full_chat_history
            st.session_state["api_chat_history"].append(new_message)
            st.session_state["full_chat_history"].append(new_message)

            # Display the latest message from the assistant
            st.chat_message("assistant", avatar='ü§ñ').write(new_message["content"])

        max_tokens = MAX_TOKENS_ALLOWED
        current_tokens = sum(count_tokens(message["content"]) for message in st.session_state["full_chat_history"])
        progress = min(1.0, max(0.0, current_tokens / max_tokens))
        st.progress(progress)
        st.write(f"Tokens Used: {current_tokens}/{max_tokens}")
        if current_tokens > max_tokens:
            st.warning("Note: Due to character limits, some older messages might not be considered in ongoing conversations with the AI.")

```

## Analytics

```python
"""Analytics functions for menu suggestions"""
from typing import List, Dict, Any
from datetime import datetime, timedelta

def get_item_suggestions(connection, item_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on order history"""
    try:
        with connection.cursor() as cursor:
            # Find items frequently ordered together
            cursor.execute("""
                WITH item_orders AS (
                    SELECT DISTINCT order_id 
                    FROM order_items 
                    WHERE item_id = %s
                ),
                related_items AS (
                    SELECT 
                        i.id,
                        i.name,
                        i.price,
                        c.name as category,
                        COUNT(*) as co_occurrence,
                        ROUND(COUNT(*) * 100.0 / (
                            SELECT COUNT(DISTINCT order_id) 
                            FROM order_items 
                            WHERE item_id = %s
                        ), 2) as order_percentage
                    FROM order_items oi
                    JOIN item_orders io ON oi.order_id = io.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE oi.item_id != %s
                      AND i.disabled = false
                      AND c.disabled = false
                    GROUP BY i.id, i.name, i.price, c.name
                    HAVING COUNT(*) >= 5
                    ORDER BY co_occurrence DESC, order_percentage DESC
                    LIMIT 5
                )
                SELECT 
                    id,
                    name,
                    price,
                    category,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders
                FROM related_items;
            """, (item_id, item_id, item_id))
            
            columns = ['id', 'name', 'price', 'category', 'times_ordered_together', 'percentage_of_orders']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def get_category_suggestions(connection, category_id: int) -> List[Dict[str, Any]]:
    """Get cross-sell suggestions based on category relationships"""
    try:
        with connection.cursor() as cursor:
            # Find categories frequently ordered together
            cursor.execute("""
                WITH category_orders AS (
                    SELECT DISTINCT o.id as order_id
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    WHERE i.category_id = %s
                ),
                related_categories AS (
                    SELECT 
                        c.id,
                        c.name,
                        COUNT(DISTINCT co.order_id) as co_occurrence,
                        ROUND(COUNT(DISTINCT co.order_id) * 100.0 / (
                            SELECT COUNT(*) FROM category_orders
                        ), 2) as order_percentage,
                        ARRAY_AGG(DISTINCT i.name) as popular_items
                    FROM category_orders co
                    JOIN order_items oi ON co.order_id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    WHERE c.id != %s
                      AND c.disabled = false
                    GROUP BY c.id, c.name
                    HAVING COUNT(DISTINCT co.order_id) >= 3
                    ORDER BY co_occurrence DESC
                    LIMIT 3
                )
                SELECT 
                    id,
                    name,
                    co_occurrence as times_ordered_together,
                    order_percentage as percentage_of_orders,
                    popular_items
                FROM related_categories;
            """, (category_id, category_id))
            
            columns = ['id', 'name', 'times_ordered_together', 'percentage_of_orders', 'popular_items']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def format_suggestion_message(item_suggestions: List[Dict[str, Any]], 
                            category_suggestions: List[Dict[str, Any]]) -> str:
    """Format suggestions into a readable message"""
    message_parts = []
    
    if item_suggestions:
        items = "\n".join(
            f"‚Ä¢ {item['name']} (${item['price']:.2f}) - "
            f"ordered together {item['times_ordered_together']} times "
            f"({item['percentage_of_orders']}% of orders)"
            for item in item_suggestions
        )
        message_parts.append(f"Suggested items:\n{items}")
    
    if category_suggestions:
        categories = "\n".join(
            f"‚Ä¢ {cat['name']} - appears in {cat['percentage_of_orders']}% "
            f"of orders with popular items: {', '.join(cat['popular_items'][:3])}"
            for cat in category_suggestions
        )
        message_parts.append(f"Suggested categories:\n{categories}")
    
    return "\n\n".join(message_parts) if message_parts else "No suggestions available"

```

## API Functions

```python
import json
import requests
from utils.config import OPENAI_API_KEY, AI_MODEL
from utils.database_functions import (
    ask_postgres_database,
    get_db_connection,
    execute_menu_update
)
from tenacity import retry, wait_random_exponential, stop_after_attempt



@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))
def send_api_request_to_openai_api(messages, functions=None, function_call=None, model=AI_MODEL, openai_api_key=OPENAI_API_KEY):
    """ Send the API request to the OpenAI API via Chat Completions endpoint """
    try:
        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {openai_api_key}"}
        json_data = {"model": model, "messages": messages}
        if functions: 
            json_data.update({"functions": functions})
        if function_call: 
            json_data.update({"function_call": function_call})
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, json=json_data)
        response.raise_for_status()

        return response
    
    except requests.RequestException as e:
        raise ConnectionError(f"Failed to connect to OpenAI API due to: {e}")


def execute_function_call(message):
    """ Run the function call provided by OpenAI's API response """
    try:
        function_name = message["function_call"]["name"]
        arguments = json.loads(message["function_call"]["arguments"])
        
        if function_name == "ask_postgres_database":
            query = arguments["query"]
            print(f"SQL query: {query} \n")
            results = ask_postgres_database(get_db_connection, query)
            print(f"Results A: {results} \n")
            
        elif function_name == "toggle_menu_item":
            query = arguments["query"]
            conn = get_db_connection()
            try:
                results = execute_menu_update(conn, query, "toggle_menu_item")
            finally:
                if conn:
                    conn.close()
            
        else:
            results = f"Error: function {function_name} does not exist"
            
        return results
        
    except Exception as e:
        return f"Error executing {message['function_call']['name']}: {str(e)}"


```

## Chat Functions

```python
import tiktoken
import streamlit as st
from typing import Dict, List, Any
from utils.config import AI_MODEL
from utils.api_functions import send_api_request_to_openai_api, execute_function_call
from utils.operation_patterns import match_operation, handle_operation_step
from utils.database_functions import execute_menu_update, get_db_connection
from utils.menu_analytics import (
    get_recent_operations,
    get_popular_items,
    analyze_time_patterns,
    get_category_relationships
)







def process_chat_message(message: str, history: List[Dict], functions: List[Dict]) -> Dict:
    """Process chat message with error handling
    
    Args:
        message: User message
        history: Chat history
        functions: OpenAI function definitions
        
    Returns:
        Response dict with role and content
    """
    try:
        # Check for operation in progress
        if "current_operation" in st.session_state:
            operation = st.session_state["current_operation"]
            step = operation["steps"][operation["current_step"]]
            response = handle_operation_step(operation, message)
            
            if response:
                if response["role"] == "function":
                    try:
                        # Execute operation
                        result = execute_menu_update(
                            get_db_connection,
                            response["params"]["query"],
                            operation["type"]
                        )
                        # Clear operation state
                        del st.session_state["current_operation"]
                        return {"role": "assistant", "content": result}
                    except Exception as e:
                        return {"role": "assistant", "content": f"Error executing operation: {str(e)}. Please try again."}
                else:
                    operation["current_step"] += 1
                    st.session_state["current_operation"] = operation
                    return response
        
        # Try to match new operation
        if operation := match_operation(message):
            operation["current_step"] = 0
            st.session_state["current_operation"] = operation
            return handle_operation_step(operation, message)
        
        # Fallback to OpenAI
        try:
            response = send_api_request_to_openai_api(
                history + [{"role": "user", "content": message}],
                functions
            )
            response_json = response.json()
            
            if not response_json.get("choices"):
                return {"role": "assistant", "content": "I encountered an error processing your request. Please try again."}
                
            assistant_message = response_json["choices"][0]["message"]
            
            if assistant_message["role"] == "assistant":
                if assistant_message.get("function_call"):
                    try:
                        results = execute_function_call(assistant_message)
                        return {"role": "assistant", "content": results}
                    except Exception as e:
                        return {"role": "assistant", "content": f"Error executing operation: {str(e)}. Please try again."}
                return assistant_message
            
            return {"role": "assistant", "content": "I encountered an unexpected response. Please try again."}
            
        except Exception as e:
            return {"role": "assistant", "content": f"Error communicating with AI: {str(e)}. Please try again."}
            
    except Exception as e:
        return {"role": "assistant", "content": f"I encountered an error: {str(e)}. Please try again."}

def run_chat_sequence(messages, functions):
    if "live_chat_history" not in st.session_state:
        st.session_state["live_chat_history"] = []
    
    if "current_item" not in st.session_state:
        st.session_state["current_item"] = None

    # Process latest message
    if messages and messages[-1]["role"] == "user":
        current_message = messages[-1]["content"]
        
        # Extract item name if present
        if "Club Made French Fries" in current_message:
            st.session_state["current_item"] = "Club Made French Fries"
            
            # Always update the system message (first message) with full context
            messages[0]["content"] = """You are a helpful AI assistant that helps manage restaurant menus.
            Your tasks include:
            1. Identify the type of operation (query, update price, enable/disable)
            2. Extract relevant information (item name, price, status)
            3. Execute the appropriate operation
            4. Confirm the operation was successful
            
            Available operations:
            - Query: View menu items and their details
            - Update: Modify menu item prices
            - Toggle: Enable or disable menu items
            
            Current item: Club Made French Fries
            Current request: Update price to 9.99"""
            
            # If this is a price update, format the message properly
            if "update price" in current_message.lower():
                price = current_message.split("to ")[-1].strip()
                current_message = f"Please update the price of {st.session_state['current_item']} to {price}."
                messages[-1]["content"] = current_message
        
        response = process_chat_message(current_message, messages[:-1], functions)
        
        # Skip "Which menu item?" if we already have it
        if "Which menu item?" in response.get("content", "") and st.session_state["current_item"]:
            if "update" in current_message.lower() and "price" in current_message.lower():
                price = current_message.split("to ")[-1].strip()
                messages[-1]["content"] = f"Update price of {st.session_state['current_item']} to {price}"
            response = process_chat_message(messages[-1]["content"], messages[:-1], functions)
        
        st.session_state["live_chat_history"].append(response)
        return response

    # Return a default greeting only if there's no chat history
    if not st.session_state["live_chat_history"]:
        return {"role": "assistant", "content": "Hello! I'm Andy, your menu management specialist. How can I assist you today?"}
    
    return st.session_state["live_chat_history"][-1]


def clear_chat_history():
    """ Clear the chat history stored in the Streamlit session state """
    del st.session_state["live_chat_history"]
    del st.session_state["full_chat_history"]
    del st.session_state["api_chat_history"]


def count_tokens(text):
    """ Count the total tokens used in a text string """
    if not isinstance(text, str):  
        return 0 
    encoding = tiktoken.encoding_for_model(AI_MODEL)
    total_tokens_in_text_string = len(encoding.encode(text))
    
    return total_tokens_in_text_string


def prepare_sidebar_data(database_schema_dict):
    """ Add a sidebar for visualizing the database schema objects  """
    sidebar_data = {}
    for table in database_schema_dict:
        schema_name = table["schema_name"]
        table_name = table["table_name"]
        columns = table["column_names"]

        if schema_name not in sidebar_data:
            sidebar_data[schema_name] = {}

        sidebar_data[schema_name][table_name] = columns
    return sidebar_data


```

## Configuration

```python
import os 
from dotenv import load_dotenv


load_dotenv()


# Set up Postgres database credentials
db_credentials = {
    "dbname": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"), 
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_SERVER"),
    "port": os.getenv("DB_PORT")
}

# Set up OpenAI variables 
OPENAI_API_KEY  =   os.getenv("OPENAI_API_KEY")
AI_MODEL        =   'gpt-4o-mini'
# AI_MODEL        =   'gpt-4'



# Max number of tokens permitted within a conversation exchange via OpenAI API
MAX_TOKENS_ALLOWED      =   4000


# Max number of messages to exchange with OpenAI API
MAX_MESSAGES_TO_OPENAI  =   10



# An arbitrary number to provide a buffer to avoid reaching exact token limits
TOKEN_BUFFER            =   200  

```

## Database Functions

```python
import psycopg2
import re
import json
import streamlit as st
from utils.config import db_credentials
from utils.menu_operations import add_operation_to_history
from utils.query_templates import QUERY_TEMPLATES

def get_db_connection():
    """Get database connection"""
    try:
        conn = psycopg2.connect(**db_credentials)
        conn.set_session(autocommit=True)
        return conn
    except Exception as e:
        raise ConnectionError(f"Unable to connect to the database due to: {e}")

def get_database_info(connection, schema_names):
    """ Fetches information about the schemas, tables and columns in the database """
    table_dicts = []
    for schema in schema_names:
        for table_name in get_table_names(connection, schema):
            column_names = get_column_names(connection, table_name, schema)
            table_dicts.append({"table_name": table_name, "column_names": column_names, "schema_name": schema})
    return table_dicts

def get_schema_names(database_connection):
    """ Returns a list of schema names """
    cursor = database_connection.cursor()
    cursor.execute("SELECT schema_name FROM information_schema.schemata;")
    schema_names = [row[0] for row in cursor.fetchall()]
    cursor.close()
    return schema_names

def get_table_names(connection, schema_name):
    """ Returns a list of table names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT table_name FROM information_schema.tables WHERE table_schema = '{schema_name}';")
    table_names = [table[0] for table in cursor.fetchall()]
    cursor.close()
    return table_names

def get_column_names(connection, table_name, schema_name):
    """ Returns a list of column names """
    cursor = connection.cursor()
    cursor.execute(f"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}' AND table_schema = '{schema_name}';")
    column_names = [col[0] for col in cursor.fetchall()]
    cursor.close()
    return column_names

# Initialize database schema dict
database_schema_dict = []

# Initialize database functions
def init_db():
    """Initialize database connection"""
    try:
        conn = get_db_connection()
        if conn and not conn.closed:
            print(f"Connected successfully to {db_credentials['dbname']} database")
            return True
        return False
    except Exception:
        return False

# Database schema info
def get_schema_info():
    """Get database schema information"""
    conn = get_db_connection()
    schemas = ['public']
    database_schema_dict = get_database_info(conn, schemas)
    return "\n".join(
        [
            f"Schema: {table['schema_name']}\nTable: {table['table_name']}\nColumns: {', '.join(table['column_names'])}"
            for table in database_schema_dict
        ]
    )

# Initialize schema string
database_schema_string = ""

def init_schema():
    """Initialize database schema information"""
    global database_schema_dict, database_schema_string
    try:
        conn = get_db_connection()
        schemas = ['public']
        database_schema_dict = get_database_info(conn, schemas)
        database_schema_string = get_schema_info()
        conn.close()
    except Exception as e:
        print(f"Error initializing database schema: {e}")
        database_schema_dict = []
        database_schema_string = ""

def ask_postgres_database(connection, query):
    """ Execute the SQL query provided by OpenAI and return the results """
    try:
        with connection.cursor() as cursor:
            cursor.execute(query)
            results = str(cursor.fetchall())
        return results
    except Exception as e:
        return f"Query failed with error: {e}"

def get_location_settings(connection, location_id):
    """Get location settings including common operations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT settings FROM locations WHERE id = %s", (location_id,))
            result = cursor.fetchone()
        return json.loads(result[0]) if result and result[0] else {}
    except Exception as e:
        return f"Failed to get location settings: {e}"

def update_location_settings(connection, location_id, settings):
    """Update location settings"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("UPDATE locations SET settings = %s WHERE id = %s", 
                         (json.dumps(settings), location_id))
        return "Settings updated successfully"
    except Exception as e:
        return f"Failed to update settings: {e}"

def extract_item_id(query):
    """Extract item ID from update query"""
    match = re.search(r'WHERE\s+(?:items\.)?id\s*=\s*(\d+)', query, re.IGNORECASE)
    if not match:
        raise ValueError("Update queries must include item ID in WHERE clause")
    return int(match.group(1))

def validate_time_range(time_str):
    """Validate time range format (0000-2359)"""
2[0-3])([0-5]\d)$', time_str):
        raise ValueError("Time must be in 24-hour format (0000-2359)")
    return True

def execute_menu_update(connection, query, operation_name=None):
    """Execute menu update with row-level locking and validation"""
    try:
        with connection:  # Auto-commits or rolls back
            with connection.cursor() as cursor:
                # Set transaction isolation level
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Extract and validate item ID for item updates
                item_id = None
                if "UPDATE items" in query.lower():
                    item_id = extract_item_id(query)
                    # Acquire row-level lock
                    cursor.execute("SELECT * FROM items WHERE id = %s FOR UPDATE", (item_id,))
                    
                    # Validate query plan
                    cursor.execute("EXPLAIN " + query)
                    plan = cursor.fetchall()
                    if not any('Index Scan' in str(row) for row in plan):
                        raise ValueError("Query must use index for updates")
                
                # Validate price updates
                if "UPDATE items SET price" in query.lower():
                    cursor.execute("SELECT COUNT(*) FROM (" + query.replace(";", "") + ") as q WHERE price < 0")
                    if cursor.fetchone()[0] > 0:
                        raise ValueError("Price updates must be non-negative")
                
                # Validate time ranges
                if "UPDATE categories" in query.lower() and ("start_time" in query or "end_time" in query):
end)_time\s*=\s*(\d{4})', query, re.IGNORECASE)
                    for time_str in time_matches:
                        validate_time_range(time_str)
                
                # Execute update
                cursor.execute(query)
                affected = cursor.rowcount
                
                # Record operation in history if name provided
                if operation_name and "location_id" in st.session_state:
                    settings = get_location_settings(connection, st.session_state["location_id"])
                    settings = add_operation_to_history(settings, {
                        "operation_type": "update",
                        "operation_name": operation_name,
                        "query_template": query,
                        "result_summary": f"Updated {affected} rows"
                    })
                    update_location_settings(connection, st.session_state["location_id"], settings)
                
                return f"Update successful. {affected} rows affected."
    except Exception as e:
        # Transaction will automatically rollback
        return f"Update failed: {e}"

def execute_template_query(connection, template_name: str, params: dict):
    """Execute a predefined query template"""
    try:
        with connection.cursor() as cursor:
            query = QUERY_TEMPLATES[template_name]
            cursor.execute(query, params)
            if template_name.startswith('select'):
                return cursor.fetchall()
            return f"{cursor.rowcount} rows affected"
    except Exception as e:
        return f"Query failed: {e}"

def get_location_hours(connection, location_id: int):
    """Get location hours using template"""
    return execute_template_query(
        connection,
        "view_location_hours",
        {"location_id": location_id}
    )

def update_location_hours(connection, location_id: int, day_of_week: str, 
                        open_time: str, close_time: str):
    """Update location hours using template"""
    return execute_template_query(
        connection,
        "update_location_hours",
        {
            "location_id": location_id,
            "day_of_week": day_of_week,
            "open_time": open_time,
            "close_time": close_time
        }
    )

def get_markers(connection, location_id: int):
    """Get markers using template"""
    return execute_template_query(
        connection,
        "view_markers",
        {"location_id": location_id}
    )

def add_marker(connection, marker_data: dict):
    """Add marker using template"""
    return execute_template_query(
        connection,
        "insert_marker",
        marker_data
    )

def cleanup_menu(connection, location_id: int, item_name: str, option_name: str):
    """Cleanup menu using template"""
    return execute_template_query(
        connection,
        "menu_cleanup",
        {
            "location_id": location_id,
            "item_name": item_name,
            "option_name": option_name
        }
    )

def execute_menu_query(query, params=None):
    """Execute a read-only query and return results with column names"""
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute(query, params or ())
            if cursor.description:  # Check if query returns results
                columns = [desc[0] for desc in cursor.description]
                rows = cursor.fetchall()
                results = []
                for row in rows:
                    results.append(dict(zip(columns, row)))
                return {
                    "success": True,
                    "results": results,
                    "columns": columns,
                    "query": query
                }
            return {
                "success": True,
                "affected_rows": cursor.rowcount,
                "query": query
            }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "query": query
        }
    finally:
        if conn:
            conn.close()

def process_query_results(results):
    """Convert query results to natural language using OpenAI"""
    import openai
    import os
    import json

    if not results["success"]:
        return f"Error executing query: {results['error']}"

    # Prepare context for OpenAI
    context = {
        "query": results["query"],
        "success": results["success"]
    }
    
    if "results" in results:
        context["data"] = results["results"]
        context["columns"] = results["columns"]
        result_type = "query results"
    else:
        context["affected_rows"] = results["affected_rows"]
        result_type = "update results"

    try:
        # Configure OpenAI
        openai.api_key = os.getenv("OPENAI_API_KEY")
        model = os.getenv("MODEL_FOR_ANALYSIS", "gpt-3.5-turbo")
        temp = float(os.getenv("ANALYSIS_TEMPERATURE", "0.3"))

        # Create system prompt
        system_prompt = f"""You are a helpful assistant that converts database {result_type} into natural language responses.
For query results, describe what was found in a clear, concise way.
For update results, describe what was changed and how many rows were affected.
Be concise but informative."""

        response = openai.ChatCompletion.create(
            model=model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": json.dumps(context, indent=2)}
            ],
            temperature=temp,
            max_tokens=150
        )
        
        if not response.choices:
            return "Error: No response generated"
            
        return response.choices[0].message["content"]
    except Exception as e:
        return f"Error generating response: {str(e)}"

```

## Export Code

```python
import os
from datetime import datetime

def create_code_section(title, file_content, language):
    """Create a markdown code section with title and content"""
    return f"## {title}\n\n```{language}\n{file_content}\n```\n\n"

def read_file_content(file_path):
    """Read content from a file, stripping line numbers"""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
content")
')[1] if '            return ''.join(content)
    except Exception as e:
        return f"Error reading file {file_path}: {str(e)}"

def export_codebase_to_markdown():
    # Define the core files to export
    core_files = [
        ("App", "app.py", "python"),
        ("Analytics", "utils/analytics.py", "python"),
        ("API Functions", "utils/api_functions.py", "python"), 
        ("Chat Functions", "utils/chat_functions.py", "python"),
        ("Configuration", "utils/config.py", "python"),
        ("Database Functions", "utils/database_functions.py", "python"),
        ("Export Code", "export_code.py", "python"),
        ("Function Calling Spec", "utils/function_calling_spec.py", "python"),
        ("Helper Functions", "utils/helper_functions.py", "python"),
        ("Menu Analytics", "utils/menu_analytics.py", "python"),
        ("Menu Operations", "utils/menu_operations.py", "python"),
        ("Operation Patterns", "utils/operation_patterns.py", "python"),
        ("Query Templates", "utils/query_templates.py", "python"),
        ("System Prompts", "utils/system_prompts.py", "python"),
        ("UI Components", "utils/ui_components.py", "python")
    ]

    # Create markdown content
    timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
    markdown_content = [
        f"# Menu Updater Codebase Export\n\nGenerated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    ]

    # Add project overview from README
    readme_content = read_file_content("README.md")
    markdown_content.append("# Project Overview\n\n")
    markdown_content.append(readme_content)
    markdown_content.append("\n\n# Source Code\n\n")

    # Add each core file
    for title, file_path, language in core_files:
        content = read_file_content(file_path)
        markdown_content.append(create_code_section(title, content, language))

    # Write to file
    output_dir = "exports"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    output_file = f"{output_dir}/codebase_export_{timestamp}.md"
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(''.join(markdown_content))

    print(f"Codebase exported to: {output_file}")

if __name__ == "__main__":
    export_codebase_to_markdown()
```

## Function Calling Spec

```python
from utils.database_functions import database_schema_string

# Specify function descriptions for OpenAI function calling 
functions = [
    {
        "name": "query_menu_items",
        "description": "Query menu items and their details",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to fetch menu items. Available tables and relationships:
                        - locations (id, name, description, disabled)
                        - menus (id, name, description, location_id, disabled)
                        - categories (id, name, description, menu_id, disabled, start_time, end_time)
                        - items (id, name, description, price, category_id, disabled)
                        - options (id, name, description, min, max, item_id, disabled)
                        - option_items (id, name, description, price, option_id, disabled)
                        
                        Join through proper hierarchy: locations -> menus -> categories -> items.
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "update_menu_item",
        "description": "Update menu item properties like price or description",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to update menu items. Validation rules:
                        - Prices must be non-negative
                        - Items should be disabled rather than deleted
                        - Time-based menu categories must have valid time ranges (0-2359)
                        
                        Example: UPDATE items SET price = 12.99 WHERE id = 123 AND price >= 0
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    },
    {
        "name": "toggle_menu_item",
        "description": "Enable or disable menu items and their options",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": """SQL query to update item.disabled flag. Rules:
                        - Use UPDATE items SET disabled = true/false
                        - Must include WHERE clause for safety
                        - Can enable/disable both items and their options
                        
                        Examples: 
                        - UPDATE items SET disabled = true WHERE id = 123
                        - UPDATE items SET disabled = false WHERE name LIKE '%French Fries%'
                        Write SQL only, no JSON. No line breaks."""
                }
            },
            "required": ["query"]
        }
    }
]

```

## Helper Functions

```python
import os
import datetime



def save_conversation(conversation_history, directory="conversation_history"):
    """
    Save a given conversation history to a markdown file with timestamps.
    """
    # Create the directory if it doesn't exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Get the current date and time for the filename
    current_datetime = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')
    file_path = os.path.join(directory, f"{current_datetime}.md")

    with open(file_path, 'w', encoding='utf-8') as file:
        for message in conversation_history:
            if message["role"] in ["user", "assistant"]:
                message_timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                role_icon = 'üßë‚Äçüíª' if message["role"] == "user" else 'ü§ñ'
                file.write(f"{message_timestamp} **{role_icon} {message['role'].title()}:** {message['content']}\n\n")
    
    return file_path

```

## Menu Analytics

```python
"""Menu analytics functions for AI context"""
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any
from utils.database_functions import get_location_settings

def get_recent_operations(connection, location_id: int, limit: int = 10) -> List[Dict[str, Any]]:
    """Get recent menu operations for a location"""
    try:
        settings = get_location_settings(connection, location_id)
        if isinstance(settings, str):  # Error message returned
            return []
        history = settings.get('operation_history', [])
        return history[:limit]
    except Exception as e:
        return []

def get_popular_items(connection, location_id: int) -> List[Dict[str, Any]]:
    """Get popular menu items based on analytics"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT i.id, i.name, i.price, 
                       a.views, a.orders, a.revenue,
                       a.last_ordered
                FROM items i
                JOIN menu_item_analytics a ON i.id = a.item_id
                JOIN categories c ON i.category_id = c.id
                JOIN menus m ON c.menu_id = m.id
                WHERE m.location_id = %s
                  AND i.disabled = false
                ORDER BY a.orders DESC, a.revenue DESC
                LIMIT 10
            """, (location_id,))
            columns = ['id', 'name', 'price', 'views', 'orders', 'revenue', 'last_ordered']
            return [dict(zip(columns, row)) for row in cursor.fetchall()]
    except Exception as e:
        return []

def analyze_time_patterns(connection, location_id: int) -> Dict[str, Any]:
    """Analyze time-based ordering patterns"""
    try:
        with connection.cursor() as cursor:
            # Get items with time restrictions
            cursor.execute("""
                SELECT c.name as category,
                       c.start_time,
                       c.end_time,
                       COUNT(DISTINCT i.id) as item_count,
                       SUM(a.orders) as total_orders
                FROM categories c
                JOIN items i ON i.category_id = c.id
                JOIN menu_item_analytics a ON i.id = a.item_id
                WHERE c.menu_id IN (
                    SELECT id FROM menus WHERE location_id = %s
                )
                AND c.start_time IS NOT NULL
                GROUP BY c.name, c.start_time, c.end_time
                ORDER BY c.start_time
            """, (location_id,))
            
            patterns = []
            for row in cursor.fetchall():
                patterns.append({
                    'category': row[0],
                    'time_range': f"{row[1]:04d}-{row[2]:04d}",
                    'items': row[3],
                    'orders': row[4]
                })
            
            return {
                'time_based_categories': patterns,
                'analysis_date': datetime.now().isoformat()
            }
    except Exception as e:
        return {'error': str(e)}

def get_category_relationships(connection, location_id: int) -> Dict[str, List[str]]:
    """Get commonly ordered category combinations"""
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                WITH order_categories AS (
                    SELECT DISTINCT o.id as order_id,
                           c.name as category_name
                    FROM orders o
                    JOIN order_items oi ON o.id = oi.order_id
                    JOIN items i ON oi.item_id = i.id
                    JOIN categories c ON i.category_id = c.id
                    JOIN menus m ON c.menu_id = m.id
                    WHERE m.location_id = %s
                ),
                category_pairs AS (
                    SELECT a.category_name as cat1,
                           b.category_name as cat2,
                           COUNT(*) as frequency
                    FROM order_categories a
                    JOIN order_categories b ON a.order_id = b.order_id
                    WHERE a.category_name < b.category_name
                    GROUP BY a.category_name, b.category_name
                    HAVING COUNT(*) >= 5
                    ORDER BY COUNT(*) DESC
                )
                SELECT cat1, cat2, frequency
                FROM category_pairs
                LIMIT 10
            """, (location_id,))
            
            relationships = {}
            for row in cursor.fetchall():
                if row[0] not in relationships:
                    relationships[row[0]] = []
                relationships[row[0]].append({
                    'category': row[1],
                    'frequency': row[2]
                })
            
            return relationships
    except Exception as e:
        return {}

```

## Menu Operations

```python
from datetime import datetime
import psycopg2
from typing import Dict, List, Optional, Tuple, Union

from typing import Dict, List, Any, Tuple, Union

def add_operation_to_history(
    operation_type: str,
    details: Dict,
    status: str,
    connection
) -> None:
    """
    Add an operation to the history table
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            INSERT INTO operation_history 
            (operation_type, operation_details, status, timestamp)
            VALUES (%s, %s, %s, %s)
            """,
            (operation_type, str(details), status, datetime.now())
        )
        connection.commit()
    except Exception as e:
        print(f"Error adding operation to history: {e}")
    finally:
        cursor.close()

def update_menu_item_price(
    item_id: int,
    new_price: float,
    connection
) -> Tuple[bool, str]:
    """
    Update the price of a menu item
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            "UPDATE menu_items SET price = %s WHERE item_id = %s",
            (new_price, item_id)
        )
        connection.commit()
        return True, "Price updated successfully"
    except Exception as e:
        return False, f"Error updating price: {e}"
    finally:
        cursor.close()

def update_category_time_range(
    category_id: int,
    start_time: str,
    end_time: str,
    connection
) -> Tuple[bool, str]:
    """
    Update the time range for a category
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE categories 
            SET available_start_time = %s, available_end_time = %s 
            WHERE category_id = %s
            """,
            (start_time, end_time, category_id)
        )
        connection.commit()
        return True, "Time range updated successfully"
    except Exception as e:
        return False, f"Error updating time range: {e}"
    finally:
        cursor.close()

def update_option_limits(
    option_id: int,
    min_selections: int,
    max_selections: int,
    connection
) -> Tuple[bool, str]:
    """
    Update the minimum and maximum selections for an option group
    """
    try:
        cursor = connection.cursor()
        cursor.execute(
            """
            UPDATE option_groups 
            SET min_selections = %s, max_selections = %s 
            WHERE option_group_id = %s
            """,
            (min_selections, max_selections, option_id)
        )
        connection.commit()
        return True, "Option limits updated successfully"
    except Exception as e:
        return False, f"Error updating option limits: {e}"
    finally:
        cursor.close()

def toggle_menu_item(
    item_name: str,
    disabled: bool = True,
    connection = None
) -> Tuple[bool, str]:
    """Toggle menu item enabled/disabled state
    
    Args:
        item_name: Name of the menu item
        disabled: True to disable, False to enable
        connection: Optional database connection
        
    Returns:
        Tuple of (success, message)
    """
    try:
        # Use existing disable_by_name function for transaction safety
        items = [{"id": None, "name": item_name}]
        success, message = disable_by_name(connection, "Menu Item", items)
        
        if success:
            action = "disabled" if disabled else "enabled"
            return True, f"Successfully {action} menu item: {item_name}"
        # Wrap error message to maintain consistent format
        return False, f"Error toggling menu item: {message.split(': ')[1]}"
        
    except Exception as e:
        return False, f"Error toggling menu item: {str(e)}"

def disable_by_name(
    connection,
    disable_type: str,
    items: List[Dict[str, Any]]
) -> Tuple[bool, str]:
    """Disable items or options by name with transaction safety"""
    # Prepare table name based on type
    if disable_type == "Menu Item":
        table = "items"
    elif disable_type == "Item Option":
        table = "options"
    else:
        table = "option_items"
        
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                    
                # Get IDs for locking
                ids = [item["id"] for item in items]
                id_list = ",".join(str(id) for id in ids)
                
                # Lock rows
                cursor.execute(f"SELECT id FROM {table} WHERE id IN ({id_list}) FOR UPDATE")
                
                # Perform update
                cursor.execute(f"UPDATE {table} SET disabled = true WHERE id IN ({id_list})")
                
                affected = cursor.rowcount
                return True, f"Successfully disabled {affected} {table}"
                
    except Exception as e:
        return False, f"Error disabling {table}: {str(e)}"

def disable_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching items
                cursor.execute("""
                    SELECT i.id, i.name, c.name as category
                    FROM items i
                    JOIN categories c ON i.category_id = c.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND i.deleted_at IS NULL
                    AND i.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                items = cursor.fetchall()
                
                if not items:
                    return False, f"No active items found matching '{pattern}'"
                    
                # Format items for confirmation
                items_str = "\n".join(f"- {item[1]} (in {item[2]})" for item in items)
                
                # Disable matching items
                cursor.execute("""
                    UPDATE items 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([item[0] for item in items],))
                
                return True, f"Disabled {len(items)} items:\n{items_str}"
                
    except Exception as e:
        return False, f"Error disabling items: {str(e)}"

def disable_options_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable options for items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching options
                cursor.execute("""
                    SELECT o.id, o.name, i.name as item
                    FROM options o
                    JOIN items i ON o.item_id = i.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND o.deleted_at IS NULL
                    AND o.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                options = cursor.fetchall()
                
                if not options:
                    return False, f"No active options found for items matching '{pattern}'"
                    
                # Format options for confirmation
                options_str = "\n".join(f"- {option[1]} (for {option[2]})" for option in options)
                
                # Disable matching options
                cursor.execute("""
                    UPDATE options 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([option[0] for option in options],))
                
                return True, f"Disabled {len(options)} options:\n{options_str}"
                
    except Exception as e:
        return False, f"Error disabling options: {str(e)}"

def disable_option_items_by_pattern(
    connection,
    pattern: str
) -> Tuple[bool, str]:
    """Disable option items for items matching a pattern with transaction safety"""
    try:
        with connection:
            with connection.cursor() as cursor:
                # Set transaction isolation
                cursor.execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ")
                
                # Find matching option items
                cursor.execute("""
                    SELECT oi.id, oi.name, o.name as option, i.name as item
                    FROM option_items oi
                    JOIN options o ON oi.option_id = o.id
                    JOIN items i ON o.item_id = i.id
                    WHERE LOWER(i.name) LIKE %s 
                    AND oi.deleted_at IS NULL
                    AND oi.disabled = false
                    FOR UPDATE
                """, (f"%{pattern.lower()}%",))
                option_items = cursor.fetchall()
                
                if not option_items:
                    return False, f"No active option items found for items matching '{pattern}'"
                    
                # Format option items for confirmation
                items_str = "\n".join(f"- {item[1]} (in {item[2]} for {item[3]})" for item in option_items)
                
                # Disable matching option items
                cursor.execute("""
                    UPDATE option_items 
                    SET disabled = true 
                    WHERE id = ANY(%s)
                """, ([item[0] for item in option_items],))
                
                return True, f"Disabled {len(option_items)} option items:\n{items_str}"
                
    except Exception as e:
        return False, f"Error disabling option items: {str(e)}"

```

## Operation Patterns

```python
"""Operation patterns for menu management"""
from typing import Dict, Optional, Any
from datetime import datetime
import re

# Common operation patterns
COMMON_OPERATIONS = {
    "disable_item": {
        "patterns": [
            r"disable (?:the )?(?:menu )?item(?: )?(.+)",
            r"turn off (?:menu )?item(?: )?(.+)",
            r"deactivate (?:menu )?item(?: )?(.+)"
        ],
        "steps": ["get_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Menu Item"
    },
    "disable_bulk": {
        "patterns": [
            r"disable all (.+)",
        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_by_pattern",
        "type": "Menu Item"
    },
    "disable_bulk": {
        "patterns": [
every) (.+)",
every) (.+)",
every) (.+)"  # Matches bulk disable patterns
        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_by_pattern",
        "type": "Menu Item"
    },
    "disable_bulk_options": {
        "patterns": [
ininin        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_options_by_pattern",
        "type": "Item Option"
    },
    "disable_bulk_option_items": {
        "patterns": [
ininin        ],
        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
        "function": "disable_option_items_by_pattern",
        "type": "Option Item"
    },
    "disable_item": {
        "patterns": [
            r"disable (?:the )?(?:menu )?item",
            r"turn off (?:the )?(?:menu )?item",
            r"deactivate (?:the )?(?:menu )?item"
        ],
        "steps": ["get_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Menu Item"
    },
    "disable_option": {
        "patterns": [
            r"disable (?:the )?(?:menu )?option(?! item)",
            r"turn off (?:the )?(?:menu )?option(?! item)",
            r"deactivate (?:the )?(?:menu )?option(?! item)"
        ],
        "steps": ["get_option_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Item Option"
    },
    "disable_option_item": {
        "patterns": [
            r"disable (?:the )?option item",
            r"turn off (?:the )?option item",
            r"deactivate (?:the )?option item"
        ],
        "steps": ["get_option_item_name", "confirm_disable", "execute_disable"],
        "function": "disable_by_name",
        "type": "Option Item"
    },
    "update_price": {
        "patterns": [
            r"update (?:the )?price",
            r"change (?:the )?price",
            r"set (?:the )?price"
        ],
        "steps": ["get_item_name", "get_new_price", "confirm_price", "execute_price_update"],
        "function": "update_menu_item_price"
    },
    "update_time_range": {
        "patterns": [
            r"update (?:the )?time range",
            r"change (?:the )?time range",
            r"set (?:the )?time range"
        ],
        "steps": ["get_category_name", "get_start_time", "get_end_time", "confirm_time_range", "execute_time_update"],
        "function": "update_category_time_range"
    }
}


def match_operation(query: str) -> Optional[Dict[str, Any]]:
    """Match query against common operation patterns
    
    Args:
        query: User query string
        
    Returns:
        Dict with operation type and parameters if matched,
        None otherwise
    """
    query_lower = query.lower()
    for op_type, op_data in COMMON_OPERATIONS.items():
        for pattern in op_data["patterns"]:
            if match := re.search(pattern, query_lower):
                operation = {
                    "type": op_type,
                    "steps": op_data["steps"].copy(),
                    "function": op_data["function"],
                    "item_type": op_data.get("type"),
                    "current_step": 0,
                    "params": {}
                }
                if len(match.groups()) > 0:
                    # Extract pattern from original query
                    start, end = match.span(1)
                    original_text = query[start:end]
                    
                    # Handle toggle operations
                    if op_type == "toggle_item":
                        operation_type = "disable"
                        if "enable" in query.lower():
                            operation_type = "enable"
                        elif "toggle" in query.lower():
                            operation_type = "toggle"
                            
                        return {
                            "type": "toggle_item",
                            "steps": ["confirm_items", "confirm_toggle", "execute_toggle"],
                            "function": "toggle_menu_item",
                            "item_type": "Menu Item",
                            "current_step": 0,
                            "params": {
                                "item_name": original_text,
                                "operation": operation_type
                            }
                        }
                    
                    # For options and option items, extract just the item name
                    if "option items" in query.lower():
                        # Extract item name after "for"
                        parts = query.split(" for ")
                        if len(parts) > 1:
                            # Get original case item name
                            item_name = parts[1].strip()
                            return {
                                "type": "disable_bulk_option_items",
                                "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                                "function": "disable_option_items_by_pattern",
                                "item_type": "Option Item",
                                "current_step": 0,
                                "params": {"pattern": item_name}
                            }
                    elif "options" in query.lower():
                        # Extract item name after "for"
                        parts = query.split(" for ")
                        if len(parts) > 1:
                            # Get original case item name
                            item_name = parts[1].strip()
                            return {
                                "type": "disable_bulk_options",
                                "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                                "function": "disable_options_by_pattern",
                                "item_type": "Item Option",
                                "current_step": 0,
                                "params": {"pattern": item_name}
                            }
                    # For regular items
                    return {
                        "type": "disable_bulk",
                        "steps": ["confirm_items", "confirm_disable", "execute_disable"],
                        "function": "disable_by_pattern",
                        "item_type": "Menu Item",
                        "current_step": 0,
                        "params": {"pattern": original_text.lower()}
                    }
                return operation
    return None


def handle_operation_step(
    operation: Dict[str, Any], 
    message: str
) -> Dict[str, Any]:
    """Handle operation step including bulk operations
    
    Args:
        operation: Operation dict with type, steps, and params
        message: User message
        
    Returns:
        Dict with response type and content
    """
    # Validate step index
    if operation["current_step"] >= len(operation["steps"]):
        return {"role": "assistant", "content": "I didn't understand that command. Please try again."}
        
    # Convert pattern to lowercase for consistency
    if "pattern" in operation.get("params", {}):
        operation["params"]["pattern"] = operation["params"]["pattern"].lower()
        
    step = operation["steps"][operation["current_step"]]
    # Handle confirmation steps first
    if step == "confirm_disable":
        if message and message.lower() != "yes":
            operation["params"]["item_name"] = message
            return {
                "role": "assistant",
                "content": f"Are you sure you want to disable {message}? (yes/no)"
            }
        if message and message.lower() == "yes":
            return {
                "role": "assistant",
                "content": "Are you absolutely sure? This operation cannot be undone. (yes/no)"
            }
        return {"role": "assistant", "content": "Operation cancelled"}
    
    if step == "confirm_items":
        # For bulk operations, show matching items
        try:
            from utils.menu_operations import (
                disable_by_pattern,
                disable_options_by_pattern,
                disable_option_items_by_pattern
            )
            from utils.database_functions import get_db_connection
            
            pattern = operation["params"]["pattern"]
            conn = get_db_connection()
            
            # Get current state
            if operation["type"] == "disable_bulk":
                success, result = disable_by_pattern(conn, pattern)
            elif operation["type"] == "disable_bulk_options":
                success, result = disable_options_by_pattern(conn, pattern)
            elif operation["type"] == "disable_bulk_option_items":
                success, result = disable_option_items_by_pattern(conn, pattern)
            else:
                return {"role": "assistant", "content": "Invalid operation type"}
                
            if not success:
                return {"role": "assistant", "content": result}
                
            confirmation_msg = (
                f"Found these items:\n{result}\n"
                "Would you like to proceed with disabling them? (yes/no)"
            )
            return {
                "role": "assistant",
                "content": confirmation_msg
            }
            
        except Exception as e:
            return {"role": "assistant", "content": f"Error finding items: {str(e)}"}
    
    elif step.startswith("get_"):
        # Get item/option name or value
        prompts = {
            "get_item_name": "Which menu item?",
            "get_option_name": "Which menu option?",
            "get_option_item_name": "Which option item?",
            "get_new_price": "What should the new price be?",
            "get_category_name": "Which category?",
            "get_start_time": "What should the start time be? (0000-2359)",
            "get_end_time": "What should the end time be? (0000-2359)"
        }
        return {
            "role": "assistant",
            "content": prompts.get(step, "Please provide more information")
        }
        
    elif step.startswith("confirm_"):
        # Confirm operation
        if step in ["confirm_disable", "confirm_toggle"]:
            if message.lower() != "yes":
                return {
                "role": "assistant",
                "content": "Operation cancelled"
            }
            return {
                "role": "assistant",
                "content": "Are you absolutely sure? This operation cannot be undone. (yes/no)"
            }
        else:
            operation["params"]["value"] = message
            confirms = {
                "confirm_price": f"Set price to ${message}? (yes/no)",
                "confirm_time_range": f"Set time range to {operation['params'].get('start_time', '?')}-{message}? (yes/no)"
            }
            prompt = confirms.get(step, "Please confirm (yes/no)")
            return {
                "role": "assistant",
                "content": prompt
            }
        
    elif step.startswith("execute_"):
        # Execute operation if confirmed
        if message.lower() == "yes":
            return {
                "role": "function",
                "name": operation["function"],
                "params": operation["params"]
            }
        else:
            return {
                "role": "assistant",
                "content": "Operation cancelled"
            }
            
    return {
        "role": "assistant",
        "content": "I didn't understand that. Please try again."
    }


def store_operation_history(
    settings: Dict[str, Any], 
    operation: Dict[str, Any], 
    result: Dict[str, Any]
) -> Dict[str, Any]:
    """Store operation in history
    
    Args:
        settings: Location settings dict
        operation: Operation that was executed
        result: Result of the operation
        
    Returns:
        Updated settings dict
    """
    if "operation_history" not in settings:
        settings["operation_history"] = []
        
    history_entry = {
        "type": operation["type"],
        "params": operation["params"],
        "result": result,
        "timestamp": str(datetime.now())
    }
    
    settings["operation_history"].append(history_entry)
    
    # Keep last 50 operations
    if len(settings["operation_history"]) > 50:
        settings["operation_history"] = settings["operation_history"][-50:]
        
    return settings

```

## Query Templates

```python
QUERY_TEMPLATES = {
    "view_location_hours": """
        SELECT * FROM location_hours 
        WHERE location_id = %(location_id)s
    """,
    "update_location_hours": """
        UPDATE location_hours
        SET 
            updated_at = CURRENT_TIMESTAMP,
            open_time = %(open_time)s,
            close_time = %(close_time)s
        WHERE 
            location_id = %(location_id)s
            AND day_of_week = %(day_of_week)s
    """,
    "view_markers": """
        SELECT * FROM markers 
        WHERE location_id = %(location_id)s
        ORDER BY id DESC
    """,
    "insert_marker": """
        INSERT INTO markers 
        (id, created_at, updated_at, deleted_at, name, disabled, location_id)
        VALUES
        (%(id)s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, %(deleted_at)s, 
         %(name)s, %(disabled)s, %(location_id)s)
    """,
    "menu_cleanup": """
        DO $$
        DECLARE
            v_location_id INT := %(location_id)s;
            v_item_name VARCHAR := %(item_name)s;
            v_option_name VARCHAR := %(option_name)s;
        BEGIN
            -- Delete option items first
            DELETE FROM option_items 
            WHERE id IN (
                SELECT DISTINCT oi.id 
                FROM locations l 
                INNER JOIN menus m ON m.location_id = l.id
                INNER JOIN categories c ON c.menu_id = m.id
                INNER JOIN items i ON i.category_id = c.id
                INNER JOIN options o ON o.item_id = i.id
                INNER JOIN option_items oi ON oi.option_id = o.id
                WHERE l.id = v_location_id
                AND i.name = v_item_name
                AND o.name = v_option_name
            );

            -- Then delete the options
            DELETE FROM options 
            WHERE id IN (
                SELECT DISTINCT o.id 
                FROM locations l 
                INNER JOIN menus m ON m.location_id = l.id
                INNER JOIN categories c ON c.menu_id = m.id
                INNER JOIN items i ON i.category_id = c.id
                INNER JOIN options o ON o.item_id = i.id
                WHERE l.id = v_location_id
                AND i.name = v_item_name
                AND o.name = v_option_name
            );
        END $$;
    """
} 
```

## System Prompts

```python
import psycopg2
import streamlit as st
from utils.config import db_credentials


GENERATE_SQL_PROMPT = """
You are Andy, a menu management specialist. Your mission is to help customers query and update their menu items through natural language requests. You understand restaurant operations and help customers maintain their menus efficiently.

Please follow these guidelines for menu operations:
<rules>
1. For menu queries, always join through the proper hierarchy: locations -> menus -> categories -> items
2. When updating prices, ensure values are non-negative and validate before committing
3. For item updates, use the disabled flag instead of deletion to maintain history
4. Maintain option configurations according to min/max constraints (options.min and options.max)
5. Respect time-based menu category constraints (categories.start_time and categories.end_time)
6. Use wildcards like "%keyword%" with LIKE for flexible text matching
7. Present SQL queries in a neat markdown format, like ```sql code```
8. Aim to offer just a single SQL script in one response
9. Guard against SQL injection by cleaning user inputs
10. If a query doesn't yield results, suggest similar menu items or categories
</rules>

Begin with a brief introduction as Andy and offer an overview of available metrics. However, avoid naming every table or schema. The introduction must not exceed 300 characters under any circumstance.

For each SQL output, include a brief rationale, display the outcome, and provide an explanation in context to the user's original request. Always format SQL as {{database}}.{{schema}}.{{table}}.

Before presenting, confirm the validity of SQL scripts and dataframes. Assess if a user's query truly needs a database response. If not, guide them as necessary.

"""


@st.cache_data(show_spinner=False)
def get_table_context(schema: str, table: str, db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute(f"""
    SELECT column_name, data_type FROM information_schema.columns
    WHERE table_schema = '{schema}' AND table_name = '{table}'
    """)
    columns = cursor.fetchall()

    columns_str = "\n".join([f"- **{col[0]}**: {col[1]}" for col in columns])
    context = f"""
    Table: <tableName> {schema}.{table} </tableName>
    Columns for {schema}.{table}:
    <columns>\n\n{columns_str}\n\n</columns>
    """
    cursor.close()
    conn.close()
    return context

def get_all_tables_from_db(db_credentials: dict):
    conn = psycopg2.connect(**db_credentials)
    cursor = conn.cursor()
    cursor.execute("""
    SELECT table_schema, table_name FROM information_schema.tables
    WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
    """)
    tables = cursor.fetchall()
    cursor.close()
    conn.close()
    return tables


def get_all_table_contexts(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    table_contexts = [get_table_context(schema, table, db_credentials) for schema, table in tables]
    return '\n'.join(table_contexts)


def get_data_dictionary(db_credentials: dict):
    tables = get_all_tables_from_db(db_credentials)
    data_dict = {}
    for schema, table in tables:
        conn = psycopg2.connect(**db_credentials)
        cursor = conn.cursor()
        cursor.execute(f"""
        SELECT column_name, data_type FROM information_schema.columns
        WHERE table_schema = '{schema}' AND table_name = '{table}'
        """)
        columns = cursor.fetchall()
        data_dict[f"{schema}.{table}"] = {col[0]: col[1] for col in columns}
        cursor.close()
        conn.close()
    return data_dict  


def get_final_system_prompt(db_credentials: dict):
    return GENERATE_SQL_PROMPT

if __name__ == "__main__":
    
    st.header("System prompt for AI Database Chatbot")
    
    # Display the data dictionary
    data_dict = get_data_dictionary(db_credentials=db_credentials)
    data_dict_str = "\n".join(
        [f"{table}:\n" + "\n".join(
            [f"    {column}: {dtype}" for column, dtype in columns.items()]) for table, columns in data_dict.items()])

    SYSTEM_PROMPT = get_final_system_prompt(db_credentials=db_credentials)
    st.markdown(SYSTEM_PROMPT)

```

## UI Components

```python
from typing import Dict, Any, List, Optional

"""UI components for menu operations with validation"""
import re
from typing import Dict, Any, List, Optional
import streamlit as st

from utils.database_functions import execute_menu_query

def validate_menu_update(data: Dict[str, Any]) -> List[str]:
    """Validate menu updates in real-time"""
    errors = []
    
    # Price validation
    if 'price' in data:
        try:
            price = float(data['price'])
            if price < 0:
                errors.append("Price must be non-negative")
            if price > 500:
                errors.append("Price cannot exceed $500.00")
            if len(str(price).split('.')[-1]) > 2:
                errors.append("Price cannot have more than 2 decimal places")
        except ValueError:
            errors.append("Invalid price format")
    
    # Time range validation
    if 'start_time' in data or 'end_time' in data:
        for key in ['start_time', 'end_time']:
            if key in data and data[key]:
                time_str = str(data[key])
2[0-3])([0-5]\d)$', time_str):
                    errors.append(f"{key.replace('_', ' ').title()} must be in 24-hour format (0000-2359)")
    
    # Option limits validation
    if 'min_selections' in data and 'max_selections' in data:
        min_val = data['min_selections']
        max_val = data['max_selections']
        if min_val > max_val:
            errors.append("Minimum selections cannot exceed maximum")
        if max_val > 10:
            errors.append("Maximum selections cannot exceed 10")
        if min_val < 0:
            errors.append("Minimum selections cannot be negative")
    
    return errors

def render_price_input(label: str, key: str, default: float = 0.0) -> float:
    """Render price input with validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        price = st.number_input(
            label,
            min_value=0.0,
            max_value=500.0,
            value=default,
            step=0.01,
            key=key,
            help="Enter price (0.00 - 500.00)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Price Rules:
                ‚Ä¢ Must be non-negative
                ‚Ä¢ Maximum $500.00
                ‚Ä¢ Two decimal places
            </span>
        </div>
        """, unsafe_allow_html=True)
    return price

def render_time_input(label: str, key: str, default: str = "") -> str:
    """Render time input with 24-hour format validation"""
    col1, col2 = st.columns([3, 1])
    with col1:
        time = st.text_input(
            label,
            value=default,
            key=key,
            help="Enter time in 24-hour format (0000-2359)"
        )
    with col2:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Time Format:
                ‚Ä¢ 24-hour format (0000-2359)
                ‚Ä¢ Examples: 0900, 1430, 2200
            </span>
        </div>
        """, unsafe_allow_html=True)
    
2[0-3])([0-5]\d)$', time):
        st.error('Time must be in 24-hour format (0000-2359)')
    return time

def render_option_limits(min_label: str, max_label: str, key_prefix: str) -> tuple[int, int]:
    """Render min/max selection limits with validation"""
    col1, col2, col3 = st.columns([2, 2, 1])
    
    with col1:
        min_val = st.number_input(
            min_label,
            min_value=0,
            max_value=10,
            value=0,
            step=1,
            key=f"{key_prefix}_min"
        )
    
    with col2:
        max_val = st.number_input(
            max_label,
            min_value=min_val,
            max_value=10,
            value=max(min_val, 1),
            step=1,
            key=f"{key_prefix}_max"
        )
    
    with col3:
        st.markdown("""
        <div class="tooltip" style="position:relative">
            ‚ÑπÔ∏è
            <span style="visibility:hidden;background-color:#555;color:#fff;text-align:center;
                        padding:5px;border-radius:6px;position:absolute;z-index:1;
                        bottom:125%;left:50%;margin-left:-60px;opacity:0;transition:opacity 0.3s">
                Selection Limits:
                ‚Ä¢ Min: 0-10 items
                ‚Ä¢ Max: Must be ‚â• Min
                ‚Ä¢ Used for option groups
            </span>
        </div>
        """, unsafe_allow_html=True)
    
    return min_val, max_val

def render_location_hours_editor():
    """Render UI for location hours management"""
    st.subheader("Location Hours Management")
    
    location_id = st.number_input("Location ID", min_value=1)
    day_of_week = st.selectbox("Day of Week", 
        ["Monday", "Tuesday", "Wednesday", "Thursday", 
         "Friday", "Saturday", "Sunday"])
    
    col1, col2 = st.columns(2)
    with col1:
        open_time = st.text_input("Open Time (HH:MM:SS)")
    with col2:
        close_time = st.text_input("Close Time (HH:MM:SS)")
    
    if st.button("Update Hours"):
        if not all([location_id, day_of_week, open_time, close_time]):
            st.error("All fields are required")
        else:
            return {
                "operation": "update_location_hours",
                "params": {
                    "location_id": location_id,
                    "day_of_week": day_of_week,
                    "open_time": open_time,
                    "close_time": close_time
                }
            }
    return None

def render_marker_management():
    """Render UI for marker management"""
    st.subheader("Marker Management")
    
    location_id = st.number_input("Location ID", min_value=1, key="marker_loc_id")
    marker_name = st.text_input("Marker Name")
    disabled = st.checkbox("Disabled")
    
    if st.button("Add Marker"):
        if not all([location_id, marker_name]):
            st.error("Location ID and Marker Name are required")
        else:
            return {
                "operation": "add_marker",
                "params": {
                    "id": None,  # Will be auto-generated
                    "name": marker_name,
                    "disabled": disabled,
                    "location_id": location_id,
                    "deleted_at": None
                }
            }
    return None

def render_disable_interface(connection) -> Dict[str, Any]:
    """Render interface for disabling items/options by name"""
    st.subheader("Disable Item/Option")
    
    # Item/Option selection
    disable_type = st.radio(
        "Select type to disable",
        ["Menu Item", "Item Option", "Option Item"],
        help="Choose whether to disable a menu item, an option, or an option item"
    )
    
    # Name input
    item_name = st.text_input(
        f"Enter {disable_type.lower()} name",
        help="Enter the exact name to disable"
    )
    
    if not item_name:
        return None
        
    # Query current state
    if disable_type == "Menu Item":
        query = """
            SELECT i.id, i.name, i.disabled, c.name as category
            FROM items i
            JOIN categories c ON i.category_id = c.id
            WHERE i.name ILIKE %s AND i.deleted_at IS NULL
        """
    elif disable_type == "Item Option":
        query = """
            SELECT o.id, o.name, o.disabled, i.name as item
            FROM options o
            JOIN items i ON o.item_id = i.id
            WHERE o.name ILIKE %s AND o.deleted_at IS NULL
        """
    else:  # Option Item
        query = """
            SELECT oi.id, oi.name, oi.disabled, o.name as option, i.name as item
            FROM option_items oi
            JOIN options o ON oi.option_id = o.id
            JOIN items i ON o.item_id = i.id
            WHERE oi.name ILIKE %s AND oi.deleted_at IS NULL
        """
    
    results = execute_menu_query(query, (item_name,))
    
    if not results:
        st.error(f"No {disable_type.lower()} found with name: {item_name}")
        return None
        
    # Show current state
    st.write("Current state:")
    for item in results:
        status = "Disabled" if item["disabled"] else "Enabled"
        if disable_type == "Menu Item":
            st.info(f"Item: {item['name']} ({status}) in category: {item['category']}")
        elif disable_type == "Item Option":
            st.info(f"Option: {item['name']} ({status}) for item: {item['item']}")
        else:
            st.info(f"Option Item: {item['name']} ({status}) for option: {item['option']} on item: {item['item']}")
    
    # Confirmation
    if st.button(
        f"Disable {disable_type}",
        type="primary",
        help=f"Click to disable {item_name}"
    ):
        return {
            "type": disable_type,
            "name": item_name,
            "items": results
        }
    
    return None

```

