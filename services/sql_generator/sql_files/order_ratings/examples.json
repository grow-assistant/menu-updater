[
  {
    "query": "Query item ratings",
    "sql": "SELECT \n    i.id, \n    i.name, \n    AVG(orf.value) AS average_rating,\n    COUNT(orf.id) AS review_count,\n    ROUND(COUNT(CASE WHEN orf.value >= 4 THEN 1 END)::NUMERIC / \n          NULLIF(COUNT(orf.id), 0) * 100, 2) AS positive_percentage,\n    AVG(CASE WHEN rc.label = 'How was your food?' THEN orf.value ELSE NULL END) AS avg_food_rating,\n    AVG(CASE WHEN rc.label = 'How was your service?' THEN orf.value ELSE NULL END) AS avg_service_rating,\n    AVG(CASE WHEN rc.label = 'How was your order experience?' THEN orf.value ELSE NULL END) AS avg_experience_rating,\n    COUNT(DISTINCT o.id) AS total_orders\nFROM items i\nJOIN order_items oi ON i.id = oi.item_id\nJOIN orders o ON oi.order_id = o.id\nJOIN categories c ON i.category_id = c.id\nJOIN menus m ON c.menu_id = m.id\nLEFT JOIN order_ratings r ON o.id = r.order_id\nLEFT JOIN order_ratings_feedback orf ON r.id = orf.rating_id\nLEFT JOIN rating_categories rc ON rc.id = orf.category_id\nWHERE m.location_id = 62\n  AND i.disabled = FALSE\n  AND o.status = 7\nGROUP BY i.id, i.name\nHAVING COUNT(orf.id) > 0\nORDER BY average_rating DESC, review_count DESC;"
  },
  {
    "query": "Query low rated items",
    "sql": "SELECT \n    i.id, \n    i.name, \n    AVG(orf.value) AS average_rating,\n    COUNT(orf.id) AS review_count,\n    ROUND(COUNT(CASE WHEN orf.value >= 4 THEN 1 END)::NUMERIC / \n          NULLIF(COUNT(orf.id), 0) * 100, 2) AS positive_percentage,\n    AVG(CASE WHEN rc.label = 'How was your food?' THEN orf.value ELSE NULL END) AS avg_food_rating,\n    AVG(CASE WHEN rc.label = 'How was your service?' THEN orf.value ELSE NULL END) AS avg_service_rating,\n    AVG(CASE WHEN rc.label = 'How was your order experience?' THEN orf.value ELSE NULL END) AS avg_experience_rating,\n    COUNT(DISTINCT o.id) AS total_orders\nFROM items i\nJOIN order_items oi ON i.id = oi.item_id\nJOIN orders o ON oi.order_id = o.id\nJOIN categories c ON i.category_id = c.id\nJOIN menus m ON c.menu_id = m.id\nLEFT JOIN order_ratings r ON o.id = r.order_id\nLEFT JOIN order_ratings_feedback orf ON r.id = orf.rating_id\nLEFT JOIN rating_categories rc ON rc.id = orf.category_id\nWHERE m.location_id = 62\n  AND i.disabled = FALSE\n  AND o.status = 7\nGROUP BY i.id, i.name\nHAVING COUNT(orf.id) > 0 AND AVG(orf.value) < 5\nORDER BY average_rating ASC, review_count DESC;"
  },
  {
    "query": "Query low ratings detailed with reasons",
    "sql": "SELECT DISTINCT ON (f.id)\n    l.name as location_name,\n    o.id AS order_id,\n    o.status AS order_status,\n    u.id AS user_id,\n    o.updated_at - INTERVAL '7 hours' AS updated_at,\n    u.first_name || ' ' || u.last_name AS customer,\n    r.id AS rating_id,\n    r.created_at AS rating_created_at,\n    r.updated_at AS rating_updated_at,\n    r.acknowledged AS rating_acknowledged,\n    f.id AS feedback_id,\n    CASE \n        WHEN rc.label = 'How was your service?' THEN 'Service'\n        WHEN rc.label = 'How was your order experience?' THEN 'Order Experience' \n        WHEN rc.label = 'How was your food?' THEN 'Food' \n        ELSE NULL \n    END as feedback_category,\n    f.value AS rating,\n    COALESCE(rr.label,'') AS reason,\n    COALESCE(f.notes,'') as feedback_notes\nFROM orders o\nINNER JOIN users u ON o.customer_id = u.id\nINNER JOIN locations l ON l.id = o.location_id\nLEFT JOIN discounts d on d.order_id = o.id\nINNER JOIN order_ratings r on r.order_id = o.id \nINNER JOIN order_ratings_feedback f on f.rating_id = r.id\nLEFT JOIN order_ratings_feedback_responses fr on fr.feedback_id = f.id\nLEFT JOIN rating_responses rr on rr.id = fr.response_id\nLEFT JOIN rating_categories rc ON rc.id = f.category_id\nWHERE \n    l.id = 62\n    AND o.status <> 0\n    AND r.acknowledged IS NOT NULL\n    AND f.value < 5\nORDER BY \n    f.id DESC,\n    COALESCE(rr.label,'') DESC, \n    COALESCE(f.notes,'') DESC;"
  },
  {
    "query": "Ratings trend analysis",
    "sql": "WITH monthly_ratings AS (\n    SELECT\n        DATE_TRUNC('month', r.created_at) AS month,\n        c.name AS category,\n        COUNT(orf.id) AS rating_count,\n        ROUND(AVG(orf.value), 2) AS avg_rating,\n        ROUND(\n            COUNT(CASE WHEN orf.value >= 4 THEN 1 END)::numeric / \n            NULLIF(COUNT(orf.id), 0) * 100, \n            1\n        ) AS positive_rating_percent\n    FROM\n        order_ratings r\n    JOIN\n        orders o ON r.order_id = o.id\n    JOIN\n        order_items oi ON o.id = oi.order_id\n    JOIN\n        items i ON oi.item_id = i.id\n    JOIN\n        categories c ON i.category_id = c.id\n    JOIN\n        menus m ON c.menu_id = m.id\n    JOIN\n        order_ratings_feedback orf ON r.id = orf.rating_id\n    WHERE\n        m.location_id = 62\n        AND r.created_at >= CURRENT_DATE - INTERVAL '12 months'\n        AND o.status = 7\n    GROUP BY\n        DATE_TRUNC('month', r.created_at),\n        c.name\n),\ncategory_avg AS (\n    -- Get the overall average rating for each category\n    SELECT\n        c.name AS category,\n        ROUND(AVG(orf.value), 2) AS category_avg_rating\n    FROM\n        order_ratings r\n    JOIN\n        orders o ON r.order_id = o.id\n    JOIN\n        order_items oi ON o.id = oi.order_id\n    JOIN\n        items i ON oi.item_id = i.id\n    JOIN\n        categories c ON i.category_id = c.id\n    JOIN\n        menus m ON c.menu_id = m.id\n    JOIN\n        order_ratings_feedback orf ON r.id = orf.rating_id\n    WHERE\n        m.location_id = 62\n        AND r.created_at >= CURRENT_DATE - INTERVAL '12 months'\n        AND o.status = 7\n    GROUP BY\n        c.name\n),\noverall_trend AS (\n    -- Calculate how ratings trend over time overall\n    SELECT\n        DATE_TRUNC('month', r.created_at) AS month,\n        ROUND(AVG(orf.value), 2) AS overall_avg_rating\n    FROM\n        order_ratings r\n    JOIN\n        orders o ON r.order_id = o.id\n    JOIN\n        order_items oi ON o.id = oi.order_id\n    JOIN\n        items i ON oi.item_id = i.id\n    JOIN\n        categories c ON i.category_id = c.id\n    JOIN\n        menus m ON c.menu_id = m.id\n    JOIN\n        order_ratings_feedback orf ON r.id = orf.rating_id\n    WHERE\n        m.location_id = 62\n        AND r.created_at >= CURRENT_DATE - INTERVAL '12 months'\n        AND o.status = 7\n    GROUP BY\n        DATE_TRUNC('month', r.created_at)\n)\n-- Put everything together for the trend analysis\nSELECT\n    TO_CHAR(mr.month, 'Month YYYY') AS month,\n    mr.category,\n    mr.rating_count,\n    mr.avg_rating,\n    ca.category_avg_rating,\n    ROUND(mr.avg_rating - ca.category_avg_rating, 2) AS diff_from_category_avg,\n    mr.positive_rating_percent,\n    ot.overall_avg_rating,\n    CASE\n        WHEN mr.avg_rating > LEAD(mr.avg_rating, 1) OVER (PARTITION BY mr.category ORDER BY mr.month) THEN 'Improving'\n        WHEN mr.avg_rating < LEAD(mr.avg_rating, 1) OVER (PARTITION BY mr.category ORDER BY mr.month) THEN 'Declining'\n        ELSE 'Stable'\n    END AS trend_direction\nFROM\n    monthly_ratings mr\nJOIN\n    category_avg ca ON mr.category = ca.category\nJOIN\n    overall_trend ot ON mr.month = ot.month\nORDER BY\n    mr.month DESC,\n    mr.category;"
  },
  {
    "query": "Customer feedback word analysis (feedback_word_analysis) (customer feedback word analysis)",
    "sql": "-- Customer feedback word analysis (feedback_word_analysis)\n-- Extract and analyze common words from customer feedback comments\n\nWITH feedback_words AS (\n    -- Extract individual words from feedback\n    SELECT\n        r.id AS rating_id,\n        i.id AS item_id,\n        i.name AS item_name,\n        c.name AS category,\n        orf.value AS rating,\n        orf.notes AS comment,\n        TRIM(LOWER(word)) AS word\n    FROM\n        order_ratings r\n    JOIN\n        orders o ON r.order_id = o.id\n    JOIN\n        order_items oi ON o.id = oi.order_id\n    JOIN\n        items i ON oi.item_id = i.id\n    JOIN\n        categories c ON i.category_id = c.id\n    JOIN\n        menus m ON c.menu_id = m.id\n    JOIN\n        order_ratings_feedback orf ON r.id = orf.rating_id,\n        LATERAL UNNEST(STRING_TO_ARRAY(LOWER(orf.notes), ' ')) AS word\n    WHERE\n        m.location_id = 62\n        AND r.created_at >= CURRENT_DATE - INTERVAL '90 days'\n        AND LENGTH(orf.notes) > 5\n        AND o.status = 7\n),\nword_counts AS (\n    -- Count frequency of each word by rating level\n    SELECT\n        word,\n        COUNT(*) AS total_occurrences,\n        COUNT(DISTINCT rating_id) AS appears_in_n_comments,\n        COUNT(CASE WHEN rating >= 4 THEN 1 END) AS positive_rating_count,\n        COUNT(CASE WHEN rating <= 2 THEN 1 END) AS negative_rating_count,\n        ROUND(AVG(rating), 2) AS avg_rating_with_word\n    FROM\n        feedback_words\n    WHERE\n        LENGTH(word) > 3\n        AND word NOT IN (\n            'this', 'that', 'there', 'these', 'those', 'from', 'have', 'with',\n            'they', 'would', 'could', 'should', 'were', 'their', 'when', 'what',\n            'your', 'will', 'about', 'just', 'very', 'much', 'more', 'some', 'been'\n        )\n    GROUP BY\n        word\n    HAVING\n        COUNT(*) >= 5\n),\nsentiment_words AS (\n    -- Categorize words by sentiment (positive vs negative)\n    SELECT\n        word,\n        total_occurrences,\n        appears_in_n_comments,\n        positive_rating_count,\n        negative_rating_count,\n        avg_rating_with_word,\n        ROUND(positive_rating_count::numeric / NULLIF(positive_rating_count + negative_rating_count, 0) * 100, 1) AS positivity_score,\n        CASE\n            WHEN positive_rating_count > negative_rating_count * 3 THEN 'Positive'\n            WHEN negative_rating_count > positive_rating_count * 2 THEN 'Negative'\n            ELSE 'Neutral'\n        END AS sentiment\n    FROM\n        word_counts\n),\nword_item_counts AS (\n    -- Precompute the counts of items associated with each word\n    SELECT \n        fw.word,\n        fw.item_name,\n        COUNT(*) AS item_count\n    FROM \n        feedback_words fw\n    GROUP BY \n        fw.word, fw.item_name\n)\n-- Final analysis\nSELECT\n    sw.word,\n    sw.total_occurrences,\n    sw.appears_in_n_comments,\n    sw.avg_rating_with_word,\n    sw.positivity_score,\n    sw.sentiment,\n    -- Top menu items associated with this word\n    (SELECT STRING_AGG(item_name, ', ')\n     FROM (\n         SELECT item_name\n         FROM word_item_counts wic\n         WHERE wic.word = sw.word\n         ORDER BY wic.item_count DESC\n         LIMIT 3\n     ) top_items\n    ) AS top_associated_items\nFROM\n    sentiment_words sw\nORDER BY\n    CASE sw.sentiment\n        WHEN 'Negative' THEN 1\n        WHEN 'Neutral' THEN 2\n        WHEN 'Positive' THEN 3\n    END,\n    sw.total_occurrences DESC;"
  }
]